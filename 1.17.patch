diff --git a/Jenkinsfile b/Jenkinsfile
new file mode 100644
index 000000000..bb612ed8b
--- /dev/null
+++ b/Jenkinsfile
@@ -0,0 +1,107 @@
+
+// throttle concurrent build
+properties([[$class: 'ThrottleJobProperty', categories: [], limitOneJobWithMatchingParams: false, maxConcurrentPerNode: 1, maxConcurrentTotal: 1, paramsToUseForLimit: '', throttleEnabled: true, throttleOption: 'project']])
+
+library(identifier: "visenze-lib@${params['VISENZE_LIB_BRANCH'] ?: 'master'}", changelog: false)
+
+pipeline {
+  agent {
+    label "${params.AGENT_LABEL ?: 'build'}"
+  }
+
+  options {
+    ansiColor('xterm')
+  }
+
+  stages {
+    stage('Checkout') {
+      steps {
+        checkout([
+          $class: 'GitSCM',
+          branches: scm.branches,
+          doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
+          extensions: [
+            [
+              $class: 'CloneOption',
+              noTags: true,
+              reference: '',
+              timeout: 60
+            ],
+            [
+              $class: 'SubmoduleOption',
+              disableSubmodules: false,
+              parentCredentials: true,
+              recursiveSubmodules: true,
+              trackingSubmodules: true,
+              reference: '',
+              timeout: 60
+            ],
+            [$class: 'CleanBeforeCheckout']
+          ],
+          userRemoteConfigs: scm.userRemoteConfigs
+        ])
+      }
+    }
+
+    stage('Test') {
+      when {
+        expression {
+          return canRun()
+        }
+      }
+      steps {
+        script {
+          dir('cluster-autoscaler') {
+            sh('make test-in-docker')
+          }
+        }
+      }
+    }
+
+    stage('Compile') {
+      when {
+        expression {
+          return canRun()
+        }
+      }
+      steps {
+        script {
+          dir('cluster-autoscaler') {
+            sh('make build-in-docker')
+          }
+        }
+      }
+    }
+
+    stage('Docker') {
+      when {
+        expression {
+          return canRun()
+        }
+      }
+      steps {
+        script {
+          dir('cluster-autoscaler') {
+            def version = sh(script: "grep ClusterAutoscalerVersion version/version.go",
+                             returnStdout: true).split('"')[-2]
+            def registry = 'visenze'
+            withEnv([
+              "REGISTRY=${registry}",
+              "TAG=${version}"
+            ]) {
+              sh('make make-image')
+              docker.withRegistry('', 'docker-hub-credential') {
+                def image = docker.image("${registry}/cluster-autoscaler:${version}")
+                image.push()
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+def canRun() {
+  return env.BRANCH_NAME.startsWith('release-') || env.BRANCH_NAME == 'master'
+} 
diff --git a/cluster-autoscaler/Makefile b/cluster-autoscaler/Makefile
index 21ed38ef5..91dd4d043 100644
--- a/cluster-autoscaler/Makefile
+++ b/cluster-autoscaler/Makefile
@@ -3,7 +3,7 @@ all: build
 TAG?=dev
 FLAGS=
 LDFLAGS?=-s
-ENVVAR=CGO_ENABLED=0 GO111MODULE=off
+ENVVAR=CGO_ENABLED=0 GO111MODULE=on
 GOOS?=linux
 REGISTRY?=staging-k8s.gcr.io
 ifdef BUILD_TAGS
@@ -29,7 +29,7 @@ build-binary: clean deps
 	$(ENVVAR) GOOS=$(GOOS) go build -o cluster-autoscaler ${LDFLAGS_FLAG} ${TAGS_FLAG}
 
 test-unit: clean deps build
-	GO111MODULE=off go test --test.short -race ./... ${TAGS_FLAG}
+	GO111MODULE=on go test --test.short -race ./... ${TAGS_FLAG}
 
 dev-release: build-binary execute-release
 	@echo "Release ${TAG}${FOR_PROVIDER} completed"
@@ -70,7 +70,7 @@ container: build-in-docker make-image
 	@echo "Created in-docker image ${TAG}${FOR_PROVIDER}"
 
 test-in-docker: clean docker-builder
-	docker run -v `pwd`:/gopath/src/k8s.io/autoscaler/cluster-autoscaler/ autoscaling-builder:latest bash -c 'cd /gopath/src/k8s.io/autoscaler/cluster-autoscaler && GO111MODULE=off go test -race ./... ${TAGS_FLAG}'
+	docker run -v `pwd`:/gopath/src/k8s.io/autoscaler/cluster-autoscaler/ autoscaling-builder:latest bash -c 'cd /gopath/src/k8s.io/autoscaler/cluster-autoscaler && go test -race ./... ${TAGS_FLAG}'
 
 .PHONY: all deps build test-unit clean format execute-release dev-release docker-builder build-in-docker release generate
 
diff --git a/cluster-autoscaler/cloudprovider/builder/builder_all.go b/cluster-autoscaler/cloudprovider/builder/builder_all.go
index 37fa63c84..68f133e52 100644
--- a/cluster-autoscaler/cloudprovider/builder/builder_all.go
+++ b/cluster-autoscaler/cloudprovider/builder/builder_all.go
@@ -29,6 +29,7 @@ import (
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/gce"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/magnum"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/packet"
+	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/spotinst"
 	"k8s.io/autoscaler/cluster-autoscaler/config"
 )
 
@@ -41,6 +42,7 @@ var AvailableCloudProviders = []string{
 	cloudprovider.BaiducloudProviderName,
 	cloudprovider.MagnumProviderName,
 	cloudprovider.DigitalOceanProviderName,
+	cloudprovider.SpotinstProviderName,
 	clusterapi.ProviderName,
 }
 
@@ -67,6 +69,8 @@ func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGro
 		return packet.BuildPacket(opts, do, rl)
 	case clusterapi.ProviderName:
 		return clusterapi.BuildClusterAPI(opts, do, rl)
+    case cloudprovider.SpotinstProviderName:
+		return spotinst.BuildSpotinst(opts, do, rl)
 	}
 	return nil
 }
diff --git a/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go b/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go
new file mode 100644
index 000000000..62b1e1744
--- /dev/null
+++ b/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go
@@ -0,0 +1,39 @@
+// +build spotinst
+
+/*
+Copyright 2018 The Kubernetes Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package builder
+
+import (
+"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/spotinst"
+"k8s.io/autoscaler/cluster-autoscaler/config"
+)
+
+// AvailableCloudProviders supported by the cloud provider builder.
+var AvailableCloudProviders = []string{
+	spotinst.ProviderName,
+}
+
+// DefaultCloudProvider for Spotinst-only build is spotinst.
+const DefaultCloudProvider = spotinst.ProviderName
+
+func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
+	switch opts.CloudProviderName {
+	case spotinst.ProviderName:
+		return spotinst.BuildSpotinst(opts, do, rl)
+	}
+
+	return nil
+}
diff --git a/cluster-autoscaler/cloudprovider/cloud_provider.go b/cluster-autoscaler/cloudprovider/cloud_provider.go
index d9d50d04b..c2cdb6df9 100644
--- a/cluster-autoscaler/cloudprovider/cloud_provider.go
+++ b/cluster-autoscaler/cloudprovider/cloud_provider.go
@@ -43,6 +43,8 @@ const (
 	MagnumProviderName = "magnum"
 	// KubemarkProviderName gets the provider name of kubemark
 	KubemarkProviderName = "kubemark"
+	// SpotinstProviderName gets the provider name of aws
+	SpotinstProviderName = "spotinst"
 )
 
 // CloudProvider contains configuration info and functions for interacting with
diff --git a/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go b/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go
new file mode 100644
index 000000000..8f772e57e
--- /dev/null
+++ b/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go
@@ -0,0 +1,1510 @@
+/*
+Copyright 2017 The Kubernetes Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// This file was generated by go generate; DO NOT EDIT
+
+package spotinst
+
+type instanceType struct {
+	InstanceType string
+	VCPU         int64
+	MemoryMb     int64
+	GPU          int64
+	GPUMemory    int64
+	MPSContext   int64
+}
+
+// InstanceTypes is a map of ec2 resources
+var InstanceTypes = map[string]*instanceType{
+	"a1": {
+		InstanceType: "a1",
+		VCPU:         16,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"a1.2xlarge": {
+		InstanceType: "a1.2xlarge",
+		VCPU:         8,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"a1.4xlarge": {
+		InstanceType: "a1.4xlarge",
+		VCPU:         16,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"a1.large": {
+		InstanceType: "a1.large",
+		VCPU:         2,
+		MemoryMb:     4096,
+		GPU:          0,
+	},
+	"a1.medium": {
+		InstanceType: "a1.medium",
+		VCPU:         1,
+		MemoryMb:     2048,
+		GPU:          0,
+	},
+	"a1.xlarge": {
+		InstanceType: "a1.xlarge",
+		VCPU:         4,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"c1.medium": {
+		InstanceType: "c1.medium",
+		VCPU:         2,
+		MemoryMb:     1740,
+		GPU:          0,
+	},
+	"c1.xlarge": {
+		InstanceType: "c1.xlarge",
+		VCPU:         8,
+		MemoryMb:     7168,
+		GPU:          0,
+	},
+	"c3": {
+		InstanceType: "c3",
+		VCPU:         32,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"c3.2xlarge": {
+		InstanceType: "c3.2xlarge",
+		VCPU:         8,
+		MemoryMb:     15360,
+		GPU:          0,
+	},
+	"c3.4xlarge": {
+		InstanceType: "c3.4xlarge",
+		VCPU:         16,
+		MemoryMb:     30720,
+		GPU:          0,
+	},
+	"c3.8xlarge": {
+		InstanceType: "c3.8xlarge",
+		VCPU:         32,
+		MemoryMb:     61440,
+		GPU:          0,
+	},
+	"c3.large": {
+		InstanceType: "c3.large",
+		VCPU:         2,
+		MemoryMb:     3840,
+		GPU:          0,
+	},
+	"c3.xlarge": {
+		InstanceType: "c3.xlarge",
+		VCPU:         4,
+		MemoryMb:     7680,
+		GPU:          0,
+	},
+	"c4": {
+		InstanceType: "c4",
+		VCPU:         36,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"c4.2xlarge": {
+		InstanceType: "c4.2xlarge",
+		VCPU:         8,
+		MemoryMb:     15360,
+		GPU:          0,
+	},
+	"c4.4xlarge": {
+		InstanceType: "c4.4xlarge",
+		VCPU:         16,
+		MemoryMb:     30720,
+		GPU:          0,
+	},
+	"c4.8xlarge": {
+		InstanceType: "c4.8xlarge",
+		VCPU:         36,
+		MemoryMb:     61440,
+		GPU:          0,
+	},
+	"c4.large": {
+		InstanceType: "c4.large",
+		VCPU:         2,
+		MemoryMb:     3840,
+		GPU:          0,
+	},
+	"c4.xlarge": {
+		InstanceType: "c4.xlarge",
+		VCPU:         4,
+		MemoryMb:     7680,
+		GPU:          0,
+	},
+	"c5": {
+		InstanceType: "c5",
+		VCPU:         72,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"c5.12xlarge": {
+		InstanceType: "c5.12xlarge",
+		VCPU:         48,
+		MemoryMb:     98304,
+		GPU:          0,
+	},
+	"c5.18xlarge": {
+		InstanceType: "c5.18xlarge",
+		VCPU:         72,
+		MemoryMb:     147456,
+		GPU:          0,
+	},
+	"c5.24xlarge": {
+		InstanceType: "c5.24xlarge",
+		VCPU:         96,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"c5.2xlarge": {
+		InstanceType: "c5.2xlarge",
+		VCPU:         8,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"c5.4xlarge": {
+		InstanceType: "c5.4xlarge",
+		VCPU:         16,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"c5.9xlarge": {
+		InstanceType: "c5.9xlarge",
+		VCPU:         36,
+		MemoryMb:     73728,
+		GPU:          0,
+	},
+	"c5.large": {
+		InstanceType: "c5.large",
+		VCPU:         2,
+		MemoryMb:     4096,
+		GPU:          0,
+	},
+	"c5.metal": {
+		InstanceType: "c5.metal",
+		VCPU:         96,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"c5.xlarge": {
+		InstanceType: "c5.xlarge",
+		VCPU:         4,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"c5d": {
+		InstanceType: "c5d",
+		VCPU:         72,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"c5d.18xlarge": {
+		InstanceType: "c5d.18xlarge",
+		VCPU:         72,
+		MemoryMb:     147456,
+		GPU:          0,
+	},
+	"c5d.2xlarge": {
+		InstanceType: "c5d.2xlarge",
+		VCPU:         8,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"c5d.4xlarge": {
+		InstanceType: "c5d.4xlarge",
+		VCPU:         16,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"c5d.9xlarge": {
+		InstanceType: "c5d.9xlarge",
+		VCPU:         36,
+		MemoryMb:     73728,
+		GPU:          0,
+	},
+	"c5d.large": {
+		InstanceType: "c5d.large",
+		VCPU:         2,
+		MemoryMb:     4096,
+		GPU:          0,
+	},
+	"c5d.xlarge": {
+		InstanceType: "c5d.xlarge",
+		VCPU:         4,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"c5n": {
+		InstanceType: "c5n",
+		VCPU:         72,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"c5n.18xlarge": {
+		InstanceType: "c5n.18xlarge",
+		VCPU:         72,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"c5n.2xlarge": {
+		InstanceType: "c5n.2xlarge",
+		VCPU:         8,
+		MemoryMb:     21504,
+		GPU:          0,
+	},
+	"c5n.4xlarge": {
+		InstanceType: "c5n.4xlarge",
+		VCPU:         16,
+		MemoryMb:     43008,
+		GPU:          0,
+	},
+	"c5n.9xlarge": {
+		InstanceType: "c5n.9xlarge",
+		VCPU:         36,
+		MemoryMb:     98304,
+		GPU:          0,
+	},
+	"c5n.large": {
+		InstanceType: "c5n.large",
+		VCPU:         2,
+		MemoryMb:     5376,
+		GPU:          0,
+	},
+	"c5n.xlarge": {
+		InstanceType: "c5n.xlarge",
+		VCPU:         4,
+		MemoryMb:     10752,
+		GPU:          0,
+	},
+	"cc2.8xlarge": {
+		InstanceType: "cc2.8xlarge",
+		VCPU:         32,
+		MemoryMb:     61952,
+		GPU:          0,
+	},
+	"cg1.4xlarge": {
+		InstanceType: "cg1.4xlarge",
+		VCPU:         16,
+		MemoryMb:     23040,
+		GPU:          0,
+	},
+	"cr1.8xlarge": {
+		InstanceType: "cr1.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"d2": {
+		InstanceType: "d2",
+		VCPU:         36,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"d2.2xlarge": {
+		InstanceType: "d2.2xlarge",
+		VCPU:         8,
+		MemoryMb:     62464,
+		GPU:          0,
+	},
+	"d2.4xlarge": {
+		InstanceType: "d2.4xlarge",
+		VCPU:         16,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"d2.8xlarge": {
+		InstanceType: "d2.8xlarge",
+		VCPU:         36,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"d2.xlarge": {
+		InstanceType: "d2.xlarge",
+		VCPU:         4,
+		MemoryMb:     31232,
+		GPU:          0,
+	},
+	"f1": {
+		InstanceType: "f1",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"f1.16xlarge": {
+		InstanceType: "f1.16xlarge",
+		VCPU:         64,
+		MemoryMb:     999424,
+		GPU:          0,
+	},
+	"f1.2xlarge": {
+		InstanceType: "f1.2xlarge",
+		VCPU:         8,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"f1.4xlarge": {
+		InstanceType: "f1.4xlarge",
+		VCPU:         16,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"g2": {
+		InstanceType: "g2",
+		VCPU:         32,
+		MemoryMb:     0,
+		GPU:          4,
+		MPSContext:   16,
+	},
+	"g2.2xlarge": {
+		InstanceType: "g2.2xlarge",
+		VCPU:         8,
+		MemoryMb:     15360,
+		GPU:          1,
+		MPSContext:   16,
+	},
+	"g2.8xlarge": {
+		InstanceType: "g2.8xlarge",
+		VCPU:         32,
+		MemoryMb:     61440,
+		GPU:          4,
+		MPSContext:   16,
+	},
+	"g3": {
+		InstanceType: "g3",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          4,
+		GPUMemory:    31931236352,
+		MPSContext:   16,
+	},
+	"g3.16xlarge": {
+		InstanceType: "g3.16xlarge",
+		VCPU:         64,
+		MemoryMb:     499712,
+		GPU:          4,
+		GPUMemory:    31931236352,
+		MPSContext:   16,
+	},
+	"g3.4xlarge": {
+		InstanceType: "g3.4xlarge",
+		VCPU:         16,
+		MemoryMb:     124928,
+		GPU:          1,
+		GPUMemory:    7982809088,
+		MPSContext:   16,
+	},
+	"g3.8xlarge": {
+		InstanceType: "g3.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          2,
+		GPUMemory:    15965618176,
+		MPSContext:   16,
+	},
+	"g3s.xlarge": {
+		InstanceType: "g3s.xlarge",
+		VCPU:         4,
+		MemoryMb:     31232,
+		GPU:          1,
+		GPUMemory:    7982809088,
+		MPSContext:   16,
+	},
+	"h1": {
+		InstanceType: "h1",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"h1.16xlarge": {
+		InstanceType: "h1.16xlarge",
+		VCPU:         64,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"h1.2xlarge": {
+		InstanceType: "h1.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"h1.4xlarge": {
+		InstanceType: "h1.4xlarge",
+		VCPU:         16,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"h1.8xlarge": {
+		InstanceType: "h1.8xlarge",
+		VCPU:         32,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"hs1.8xlarge": {
+		InstanceType: "hs1.8xlarge",
+		VCPU:         17,
+		MemoryMb:     119808,
+		GPU:          0,
+	},
+	"i2": {
+		InstanceType: "i2",
+		VCPU:         32,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"i2.2xlarge": {
+		InstanceType: "i2.2xlarge",
+		VCPU:         8,
+		MemoryMb:     62464,
+		GPU:          0,
+	},
+	"i2.4xlarge": {
+		InstanceType: "i2.4xlarge",
+		VCPU:         16,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"i2.8xlarge": {
+		InstanceType: "i2.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"i2.xlarge": {
+		InstanceType: "i2.xlarge",
+		VCPU:         4,
+		MemoryMb:     31232,
+		GPU:          0,
+	},
+	"i3": {
+		InstanceType: "i3",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"i3.16xlarge": {
+		InstanceType: "i3.16xlarge",
+		VCPU:         64,
+		MemoryMb:     499712,
+		GPU:          0,
+	},
+	"i3.2xlarge": {
+		InstanceType: "i3.2xlarge",
+		VCPU:         8,
+		MemoryMb:     62464,
+		GPU:          0,
+	},
+	"i3.4xlarge": {
+		InstanceType: "i3.4xlarge",
+		VCPU:         16,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"i3.8xlarge": {
+		InstanceType: "i3.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"i3.large": {
+		InstanceType: "i3.large",
+		VCPU:         2,
+		MemoryMb:     15616,
+		GPU:          0,
+	},
+	"i3.metal": {
+		InstanceType: "i3.metal",
+		VCPU:         72,
+		MemoryMb:     524288,
+		GPU:          0,
+	},
+	"i3.xlarge": {
+		InstanceType: "i3.xlarge",
+		VCPU:         4,
+		MemoryMb:     31232,
+		GPU:          0,
+	},
+	"i3en": {
+		InstanceType: "i3en",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"i3en.12xlarge": {
+		InstanceType: "i3en.12xlarge",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"i3en.24xlarge": {
+		InstanceType: "i3en.24xlarge",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"i3en.2xlarge": {
+		InstanceType: "i3en.2xlarge",
+		VCPU:         8,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"i3en.3xlarge": {
+		InstanceType: "i3en.3xlarge",
+		VCPU:         12,
+		MemoryMb:     98304,
+		GPU:          0,
+	},
+	"i3en.6xlarge": {
+		InstanceType: "i3en.6xlarge",
+		VCPU:         24,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"i3en.large": {
+		InstanceType: "i3en.large",
+		VCPU:         2,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"i3en.xlarge": {
+		InstanceType: "i3en.xlarge",
+		VCPU:         4,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"m1.large": {
+		InstanceType: "m1.large",
+		VCPU:         2,
+		MemoryMb:     7680,
+		GPU:          0,
+	},
+	"m1.medium": {
+		InstanceType: "m1.medium",
+		VCPU:         1,
+		MemoryMb:     3840,
+		GPU:          0,
+	},
+	"m1.small": {
+		InstanceType: "m1.small",
+		VCPU:         1,
+		MemoryMb:     1740,
+		GPU:          0,
+	},
+	"m1.xlarge": {
+		InstanceType: "m1.xlarge",
+		VCPU:         4,
+		MemoryMb:     15360,
+		GPU:          0,
+	},
+	"m2.2xlarge": {
+		InstanceType: "m2.2xlarge",
+		VCPU:         4,
+		MemoryMb:     35020,
+		GPU:          0,
+	},
+	"m2.4xlarge": {
+		InstanceType: "m2.4xlarge",
+		VCPU:         8,
+		MemoryMb:     70041,
+		GPU:          0,
+	},
+	"m2.xlarge": {
+		InstanceType: "m2.xlarge",
+		VCPU:         2,
+		MemoryMb:     17510,
+		GPU:          0,
+	},
+	"m3": {
+		InstanceType: "m3",
+		VCPU:         8,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"m3.2xlarge": {
+		InstanceType: "m3.2xlarge",
+		VCPU:         8,
+		MemoryMb:     30720,
+		GPU:          0,
+	},
+	"m3.large": {
+		InstanceType: "m3.large",
+		VCPU:         2,
+		MemoryMb:     7680,
+		GPU:          0,
+	},
+	"m3.medium": {
+		InstanceType: "m3.medium",
+		VCPU:         1,
+		MemoryMb:     3840,
+		GPU:          0,
+	},
+	"m3.xlarge": {
+		InstanceType: "m3.xlarge",
+		VCPU:         4,
+		MemoryMb:     15360,
+		GPU:          0,
+	},
+	"m4": {
+		InstanceType: "m4",
+		VCPU:         40,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"m4.10xlarge": {
+		InstanceType: "m4.10xlarge",
+		VCPU:         40,
+		MemoryMb:     163840,
+		GPU:          0,
+	},
+	"m4.16xlarge": {
+		InstanceType: "m4.16xlarge",
+		VCPU:         64,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"m4.2xlarge": {
+		InstanceType: "m4.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"m4.4xlarge": {
+		InstanceType: "m4.4xlarge",
+		VCPU:         16,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"m4.large": {
+		InstanceType: "m4.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"m4.xlarge": {
+		InstanceType: "m4.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"m5": {
+		InstanceType: "m5",
+		VCPU:         96,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"m5.12xlarge": {
+		InstanceType: "m5.12xlarge",
+		VCPU:         48,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"m5.16xlarge": {
+		InstanceType: "m5.16xlarge",
+		VCPU:         64,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"m5.24xlarge": {
+		InstanceType: "m5.24xlarge",
+		VCPU:         96,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"m5.2xlarge": {
+		InstanceType: "m5.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"m5.4xlarge": {
+		InstanceType: "m5.4xlarge",
+		VCPU:         16,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"m5.8xlarge": {
+		InstanceType: "m5.8xlarge",
+		VCPU:         32,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"m5.large": {
+		InstanceType: "m5.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"m5.metal": {
+		InstanceType: "m5.metal",
+		VCPU:         96,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"m5.xlarge": {
+		InstanceType: "m5.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"m5a.12xlarge": {
+		InstanceType: "m5a.12xlarge",
+		VCPU:         48,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"m5a.16xlarge": {
+		InstanceType: "m5a.16xlarge",
+		VCPU:         64,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"m5a.24xlarge": {
+		InstanceType: "m5a.24xlarge",
+		VCPU:         96,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"m5a.2xlarge": {
+		InstanceType: "m5a.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"m5a.4xlarge": {
+		InstanceType: "m5a.4xlarge",
+		VCPU:         16,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"m5a.8xlarge": {
+		InstanceType: "m5a.8xlarge",
+		VCPU:         32,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"m5a.large": {
+		InstanceType: "m5a.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"m5a.xlarge": {
+		InstanceType: "m5a.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"m5ad.12xlarge": {
+		InstanceType: "m5ad.12xlarge",
+		VCPU:         48,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"m5ad.24xlarge": {
+		InstanceType: "m5ad.24xlarge",
+		VCPU:         96,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"m5ad.2xlarge": {
+		InstanceType: "m5ad.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"m5ad.4xlarge": {
+		InstanceType: "m5ad.4xlarge",
+		VCPU:         16,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"m5ad.large": {
+		InstanceType: "m5ad.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"m5ad.xlarge": {
+		InstanceType: "m5ad.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"m5d": {
+		InstanceType: "m5d",
+		VCPU:         96,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"m5d.12xlarge": {
+		InstanceType: "m5d.12xlarge",
+		VCPU:         48,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"m5d.16xlarge": {
+		InstanceType: "m5d.16xlarge",
+		VCPU:         64,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"m5d.24xlarge": {
+		InstanceType: "m5d.24xlarge",
+		VCPU:         96,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"m5d.2xlarge": {
+		InstanceType: "m5d.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"m5d.4xlarge": {
+		InstanceType: "m5d.4xlarge",
+		VCPU:         16,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"m5d.8xlarge": {
+		InstanceType: "m5d.8xlarge",
+		VCPU:         32,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"m5d.large": {
+		InstanceType: "m5d.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"m5d.metal": {
+		InstanceType: "m5d.metal",
+		VCPU:         96,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"m5d.xlarge": {
+		InstanceType: "m5d.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"p2": {
+		InstanceType: "p2",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          16,
+		GPUMemory:    12000000000, // Rough estimate of 12 GB
+		MPSContext:   16,
+	},
+	"p2.16xlarge": {
+		InstanceType: "p2.16xlarge",
+		VCPU:         64,
+		MemoryMb:     786432,
+		GPU:          16,
+		GPUMemory:    192000000000,
+		MPSContext:   16,
+	},
+	"p2.8xlarge": {
+		InstanceType: "p2.8xlarge",
+		VCPU:         32,
+		MemoryMb:     499712,
+		GPU:          8,
+		GPUMemory:    96000000000,
+		MPSContext:   16,
+	},
+	"p2.xlarge": {
+		InstanceType: "p2.xlarge",
+		VCPU:         4,
+		MemoryMb:     62464,
+		GPU:          1,
+		GPUMemory:    12000000000,
+		MPSContext:   16,
+	},
+	"p3": {
+		InstanceType: "p3",
+		VCPU:         64,
+		MemoryMb:     499712,
+		GPU:          8,
+		GPUMemory:    16000000000,
+		MPSContext:   48,
+	},
+	"p3.16xlarge": {
+		InstanceType: "p3.16xlarge",
+		VCPU:         64,
+		MemoryMb:     499712,
+		GPU:          8,
+		GPUMemory:    128000000000,
+		MPSContext:   48,
+	},
+	"p3.2xlarge": {
+		InstanceType: "p3.2xlarge",
+		VCPU:         8,
+		MemoryMb:     62464,
+		GPU:          1,
+		GPUMemory:    16000000000,
+		MPSContext:   48,
+	},
+	"p3.8xlarge": {
+		InstanceType: "p3.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          4,
+		GPUMemory:    64000000000,
+		MPSContext:   48,
+	},
+	"r3": {
+		InstanceType: "r3",
+		VCPU:         32,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"r3.2xlarge": {
+		InstanceType: "r3.2xlarge",
+		VCPU:         8,
+		MemoryMb:     62464,
+		GPU:          0,
+	},
+	"r3.4xlarge": {
+		InstanceType: "r3.4xlarge",
+		VCPU:         16,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"r3.8xlarge": {
+		InstanceType: "r3.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"r3.large": {
+		InstanceType: "r3.large",
+		VCPU:         2,
+		MemoryMb:     15616,
+		GPU:          0,
+	},
+	"r3.xlarge": {
+		InstanceType: "r3.xlarge",
+		VCPU:         4,
+		MemoryMb:     31232,
+		GPU:          0,
+	},
+	"r4": {
+		InstanceType: "r4",
+		VCPU:         64,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"r4.16xlarge": {
+		InstanceType: "r4.16xlarge",
+		VCPU:         64,
+		MemoryMb:     499712,
+		GPU:          0,
+	},
+	"r4.2xlarge": {
+		InstanceType: "r4.2xlarge",
+		VCPU:         8,
+		MemoryMb:     62464,
+		GPU:          0,
+	},
+	"r4.4xlarge": {
+		InstanceType: "r4.4xlarge",
+		VCPU:         16,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"r4.8xlarge": {
+		InstanceType: "r4.8xlarge",
+		VCPU:         32,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"r4.large": {
+		InstanceType: "r4.large",
+		VCPU:         2,
+		MemoryMb:     15616,
+		GPU:          0,
+	},
+	"r4.xlarge": {
+		InstanceType: "r4.xlarge",
+		VCPU:         4,
+		MemoryMb:     31232,
+		GPU:          0,
+	},
+	"r5": {
+		InstanceType: "r5",
+		VCPU:         96,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"r5.12xlarge": {
+		InstanceType: "r5.12xlarge",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"r5.16xlarge": {
+		InstanceType: "r5.16xlarge",
+		VCPU:         64,
+		MemoryMb:     524288,
+		GPU:          0,
+	},
+	"r5.24xlarge": {
+		InstanceType: "r5.24xlarge",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"r5.2xlarge": {
+		InstanceType: "r5.2xlarge",
+		VCPU:         8,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"r5.4xlarge": {
+		InstanceType: "r5.4xlarge",
+		VCPU:         16,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"r5.8xlarge": {
+		InstanceType: "r5.8xlarge",
+		VCPU:         32,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"r5.large": {
+		InstanceType: "r5.large",
+		VCPU:         2,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"r5.metal": {
+		InstanceType: "r5.metal",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"r5.xlarge": {
+		InstanceType: "r5.xlarge",
+		VCPU:         4,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"r5a.12xlarge": {
+		InstanceType: "r5a.12xlarge",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"r5a.16xlarge": {
+		InstanceType: "r5a.16xlarge",
+		VCPU:         64,
+		MemoryMb:     524288,
+		GPU:          0,
+	},
+	"r5a.24xlarge": {
+		InstanceType: "r5a.24xlarge",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"r5a.2xlarge": {
+		InstanceType: "r5a.2xlarge",
+		VCPU:         8,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"r5a.4xlarge": {
+		InstanceType: "r5a.4xlarge",
+		VCPU:         16,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"r5a.8xlarge": {
+		InstanceType: "r5a.8xlarge",
+		VCPU:         32,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"r5a.large": {
+		InstanceType: "r5a.large",
+		VCPU:         2,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"r5a.xlarge": {
+		InstanceType: "r5a.xlarge",
+		VCPU:         4,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"r5ad.12xlarge": {
+		InstanceType: "r5ad.12xlarge",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"r5ad.24xlarge": {
+		InstanceType: "r5ad.24xlarge",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"r5ad.2xlarge": {
+		InstanceType: "r5ad.2xlarge",
+		VCPU:         8,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"r5ad.4xlarge": {
+		InstanceType: "r5ad.4xlarge",
+		VCPU:         16,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"r5ad.large": {
+		InstanceType: "r5ad.large",
+		VCPU:         2,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"r5ad.xlarge": {
+		InstanceType: "r5ad.xlarge",
+		VCPU:         4,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"r5d": {
+		InstanceType: "r5d",
+		VCPU:         96,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"r5d.12xlarge": {
+		InstanceType: "r5d.12xlarge",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"r5d.16xlarge": {
+		InstanceType: "r5d.16xlarge",
+		VCPU:         64,
+		MemoryMb:     524288,
+		GPU:          0,
+	},
+	"r5d.24xlarge": {
+		InstanceType: "r5d.24xlarge",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"r5d.2xlarge": {
+		InstanceType: "r5d.2xlarge",
+		VCPU:         8,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"r5d.4xlarge": {
+		InstanceType: "r5d.4xlarge",
+		VCPU:         16,
+		MemoryMb:     131072,
+		GPU:          0,
+	},
+	"r5d.8xlarge": {
+		InstanceType: "r5d.8xlarge",
+		VCPU:         32,
+		MemoryMb:     262144,
+		GPU:          0,
+	},
+	"r5d.large": {
+		InstanceType: "r5d.large",
+		VCPU:         2,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"r5d.metal": {
+		InstanceType: "r5d.metal",
+		VCPU:         96,
+		MemoryMb:     786432,
+		GPU:          0,
+	},
+	"r5d.xlarge": {
+		InstanceType: "r5d.xlarge",
+		VCPU:         4,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"t1.micro": {
+		InstanceType: "t1.micro",
+		VCPU:         1,
+		MemoryMb:     627,
+		GPU:          0,
+	},
+	"t2.2xlarge": {
+		InstanceType: "t2.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"t2.large": {
+		InstanceType: "t2.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"t2.medium": {
+		InstanceType: "t2.medium",
+		VCPU:         2,
+		MemoryMb:     4096,
+		GPU:          0,
+	},
+	"t2.micro": {
+		InstanceType: "t2.micro",
+		VCPU:         1,
+		MemoryMb:     1024,
+		GPU:          0,
+	},
+	"t2.nano": {
+		InstanceType: "t2.nano",
+		VCPU:         1,
+		MemoryMb:     512,
+		GPU:          0,
+	},
+	"t2.small": {
+		InstanceType: "t2.small",
+		VCPU:         1,
+		MemoryMb:     2048,
+		GPU:          0,
+	},
+	"t2.xlarge": {
+		InstanceType: "t2.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"t3.2xlarge": {
+		InstanceType: "t3.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"t3.large": {
+		InstanceType: "t3.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"t3.medium": {
+		InstanceType: "t3.medium",
+		VCPU:         2,
+		MemoryMb:     4096,
+		GPU:          0,
+	},
+	"t3.micro": {
+		InstanceType: "t3.micro",
+		VCPU:         2,
+		MemoryMb:     1024,
+		GPU:          0,
+	},
+	"t3.nano": {
+		InstanceType: "t3.nano",
+		VCPU:         2,
+		MemoryMb:     512,
+		GPU:          0,
+	},
+	"t3.small": {
+		InstanceType: "t3.small",
+		VCPU:         2,
+		MemoryMb:     2048,
+		GPU:          0,
+	},
+	"t3.xlarge": {
+		InstanceType: "t3.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"t3a.2xlarge": {
+		InstanceType: "t3a.2xlarge",
+		VCPU:         8,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+	"t3a.large": {
+		InstanceType: "t3a.large",
+		VCPU:         2,
+		MemoryMb:     8192,
+		GPU:          0,
+	},
+	"t3a.medium": {
+		InstanceType: "t3a.medium",
+		VCPU:         2,
+		MemoryMb:     4096,
+		GPU:          0,
+	},
+	"t3a.micro": {
+		InstanceType: "t3a.micro",
+		VCPU:         2,
+		MemoryMb:     1024,
+		GPU:          0,
+	},
+	"t3a.nano": {
+		InstanceType: "t3a.nano",
+		VCPU:         2,
+		MemoryMb:     512,
+		GPU:          0,
+	},
+	"t3a.small": {
+		InstanceType: "t3a.small",
+		VCPU:         2,
+		MemoryMb:     2048,
+		GPU:          0,
+	},
+	"t3a.xlarge": {
+		InstanceType: "t3a.xlarge",
+		VCPU:         4,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"u-12tb1": {
+		InstanceType: "u-12tb1",
+		VCPU:         448,
+		MemoryMb:     12582912,
+		GPU:          0,
+	},
+	"u-6tb1": {
+		InstanceType: "u-6tb1",
+		VCPU:         448,
+		MemoryMb:     6291456,
+		GPU:          0,
+	},
+	"u-9tb1": {
+		InstanceType: "u-9tb1",
+		VCPU:         448,
+		MemoryMb:     9437184,
+		GPU:          0,
+	},
+	"x1": {
+		InstanceType: "x1",
+		VCPU:         128,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"x1.16xlarge": {
+		InstanceType: "x1.16xlarge",
+		VCPU:         64,
+		MemoryMb:     999424,
+		GPU:          0,
+	},
+	"x1.32xlarge": {
+		InstanceType: "x1.32xlarge",
+		VCPU:         128,
+		MemoryMb:     1998848,
+		GPU:          0,
+	},
+	"x1e": {
+		InstanceType: "x1e",
+		VCPU:         128,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"x1e.16xlarge": {
+		InstanceType: "x1e.16xlarge",
+		VCPU:         64,
+		MemoryMb:     1998848,
+		GPU:          0,
+	},
+	"x1e.2xlarge": {
+		InstanceType: "x1e.2xlarge",
+		VCPU:         8,
+		MemoryMb:     249856,
+		GPU:          0,
+	},
+	"x1e.32xlarge": {
+		InstanceType: "x1e.32xlarge",
+		VCPU:         128,
+		MemoryMb:     3997696,
+		GPU:          0,
+	},
+	"x1e.4xlarge": {
+		InstanceType: "x1e.4xlarge",
+		VCPU:         16,
+		MemoryMb:     499712,
+		GPU:          0,
+	},
+	"x1e.8xlarge": {
+		InstanceType: "x1e.8xlarge",
+		VCPU:         32,
+		MemoryMb:     999424,
+		GPU:          0,
+	},
+	"x1e.xlarge": {
+		InstanceType: "x1e.xlarge",
+		VCPU:         4,
+		MemoryMb:     124928,
+		GPU:          0,
+	},
+	"z1d": {
+		InstanceType: "z1d",
+		VCPU:         48,
+		MemoryMb:     0,
+		GPU:          0,
+	},
+	"z1d.12xlarge": {
+		InstanceType: "z1d.12xlarge",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"z1d.2xlarge": {
+		InstanceType: "z1d.2xlarge",
+		VCPU:         8,
+		MemoryMb:     65536,
+		GPU:          0,
+	},
+	"z1d.3xlarge": {
+		InstanceType: "z1d.3xlarge",
+		VCPU:         12,
+		MemoryMb:     98304,
+		GPU:          0,
+	},
+	"z1d.6xlarge": {
+		InstanceType: "z1d.6xlarge",
+		VCPU:         24,
+		MemoryMb:     196608,
+		GPU:          0,
+	},
+	"z1d.large": {
+		InstanceType: "z1d.large",
+		VCPU:         2,
+		MemoryMb:     16384,
+		GPU:          0,
+	},
+	"z1d.metal": {
+		InstanceType: "z1d.metal",
+		VCPU:         48,
+		MemoryMb:     393216,
+		GPU:          0,
+	},
+	"z1d.xlarge": {
+		InstanceType: "z1d.xlarge",
+		VCPU:         4,
+		MemoryMb:     32768,
+		GPU:          0,
+	},
+}
diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go
new file mode 100644
index 000000000..7644f921d
--- /dev/null
+++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go
@@ -0,0 +1,152 @@
+/*
+Copyright 2016 The Kubernetes Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package spotinst
+
+import (
+	"io"
+	apiv1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+	"k8s.io/autoscaler/cluster-autoscaler/config"
+	"k8s.io/autoscaler/cluster-autoscaler/utils/errors"
+	"k8s.io/klog"
+	"os"
+)
+
+const (
+	ProviderName = "spotinst"
+
+	// GPULabel is the label added to nodes with GPU resource.
+	GPULabel = "k8s.amazonaws.com/accelerator"
+)
+
+// CloudProvider implements CloudProvider interface.
+type CloudProvider struct {
+	manager         *CloudManager
+	resourceLimiter *cloudprovider.ResourceLimiter
+}
+
+var (
+	availableGPUTypes = map[string]struct{}{
+		"nvidia-tesla-k80":  {},
+		"nvidia-tesla-p100": {},
+		"nvidia-tesla-v100": {},
+	}
+)
+
+// NewCloudProvider returns CloudProvider implementation for Spotinst.
+func NewCloudProvider(manager *CloudManager, resourceLimiter *cloudprovider.ResourceLimiter) (*CloudProvider, error) {
+	klog.Info("Building Spotinst cloud provider")
+	cloud := &CloudProvider{
+		manager:         manager,
+		resourceLimiter: resourceLimiter,
+	}
+
+	return cloud, nil
+}
+
+// Name returns name of the cloud c.
+func (c *CloudProvider) Name() string {
+	return ProviderName
+}
+
+// NodeGroups returns all node groups configured for this cloud c.
+func (c *CloudProvider) NodeGroups() []cloudprovider.NodeGroup {
+	out := make([]cloudprovider.NodeGroup, len(c.manager.groups))
+	for i, group := range c.manager.groups {
+		out[i] = group
+	}
+	return out
+}
+
+// NodeGroupForNode returns the node group for the given node.
+func (c *CloudProvider) NodeGroupForNode(node *apiv1.Node) (cloudprovider.NodeGroup, error) {
+	instanceID, err := extractInstanceId(node.Spec.ProviderID)
+	if err != nil {
+		return nil, err
+	}
+	return c.manager.GetGroupForInstance(instanceID)
+}
+
+// Pricing returns pricing model for this cloud provider or error if not available.
+func (c *CloudProvider) Pricing() (cloudprovider.PricingModel, errors.AutoscalerError) {
+	return nil, cloudprovider.ErrNotImplemented
+}
+
+// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.
+// Implementation optional.
+func (c *CloudProvider) GetAvailableMachineTypes() ([]string, error) {
+	return []string{}, nil
+}
+
+// NewNodeGroup builds a theoretical node group based on the node definition provided.
+func (c *CloudProvider) NewNodeGroup(machineType string, labels map[string]string, systemLabels map[string]string,
+	taints []apiv1.Taint, extraResources map[string]resource.Quantity) (cloudprovider.NodeGroup, error) {
+	return nil, cloudprovider.ErrNotImplemented
+}
+
+// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).
+func (c *CloudProvider) GetResourceLimiter() (*cloudprovider.ResourceLimiter, error) {
+	return c.resourceLimiter, nil
+}
+
+// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.
+func (c *CloudProvider) Cleanup() error {
+	return c.manager.Cleanup()
+}
+
+// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
+// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
+func (c *CloudProvider) Refresh() error {
+	return c.manager.Refresh()
+}
+
+// GetInstanceID gets the instance ID for the specified node.
+func (c *CloudProvider) GetInstanceID(node *apiv1.Node) string {
+	return node.Spec.ProviderID
+}
+
+// GPULabel returns the label added to nodes with GPU resource.
+func (c *CloudProvider) GPULabel() string {
+	return GPULabel
+}
+
+// GetAvailableGPUTypes return all available GPU types cloud provider supports
+func (c *CloudProvider) GetAvailableGPUTypes() map[string]struct{} {
+	return availableGPUTypes
+}
+
+func BuildSpotinst(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
+	var config io.ReadCloser
+	if opts.CloudConfig != "" {
+		var err error
+		config, err = os.Open(opts.CloudConfig)
+		if err != nil {
+			klog.Fatalf("Couldn't open cloud provider configuration %s: %#v", opts.CloudConfig, err)
+		}
+		defer config.Close()
+	}
+
+	manager, err := NewCloudManager(config, do)
+	if err != nil {
+		klog.Fatalf("Failed to create Spotinst manager: %v", err)
+	}
+
+	provider, err := NewCloudProvider(manager, rl)
+	if err != nil {
+		klog.Fatalf("Failed to create Spotinst cloud provider: %v", err)
+	}
+
+	return provider
+}
diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go
new file mode 100644
index 000000000..28ee79069
--- /dev/null
+++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go
@@ -0,0 +1,409 @@
+/*
+Copyright 2016 The Kubernetes Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package spotinst
+
+import (
+	"context"
+	"testing"
+	"time"
+
+	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
+	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/azure"
+	azurev3 "github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/azure/v3"
+	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/gcp"
+	"github.com/spotinst/spotinst-sdk-go/spotinst"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/mock"
+	apiv1 "k8s.io/api/core/v1"
+	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+)
+
+type groupServiceMock struct {
+	mock.Mock
+	providerAWS *awsServiceMock
+}
+
+func (s *groupServiceMock) CloudProviderAWS() aws.Service {
+	return s.providerAWS
+}
+
+func (s *groupServiceMock) CloudProviderGCP() gcp.Service {
+	return nil // not implemented
+}
+
+func (s *groupServiceMock) CloudProviderAzure() azure.Service {
+	return nil // not implemented
+}
+
+func (s *groupServiceMock) CloudProviderAzureV3() azurev3.Service {
+	return nil // not implemented
+}
+
+type awsServiceMock struct {
+	mock.Mock
+}
+
+func (s *awsServiceMock) List(ctx context.Context, input *aws.ListGroupsInput) (*aws.ListGroupsOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) Create(ctx context.Context, input *aws.CreateGroupInput) (*aws.CreateGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) DeploymentStatusECS(context.Context, *aws.DeploymentStatusInput) (*aws.RollGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) DeploymentStatus(context.Context, *aws.DeploymentStatusInput) (*aws.RollGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) RollECS(context.Context, *aws.RollECSGroupInput) (*aws.RollGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) Scale(context.Context, *aws.ScaleGroupInput) (*aws.ScaleGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) FinishBeanstalkMaintenance(context.Context, *aws.BeanstalkMaintenanceInput) (*aws.BeanstalkMaintenanceOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) GetBeanstalkMaintenanceStatus(context.Context, *aws.BeanstalkMaintenanceInput) (*string, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) GetGroupEvents(context.Context, *aws.GetGroupEventsInput) (*aws.GetGroupEventsOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) StartBeanstalkMaintenance(context.Context, *aws.BeanstalkMaintenanceInput) (*aws.BeanstalkMaintenanceOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) Read(ctx context.Context, input *aws.ReadGroupInput) (*aws.ReadGroupOutput, error) {
+	out := &aws.ReadGroupOutput{
+		Group: &aws.Group{
+			Capacity: &aws.Capacity{
+				Target: spotinst.Int(2),
+			},
+		},
+	}
+	return out, nil
+}
+
+func (s *awsServiceMock) GetInstanceHealthiness(context.Context, *aws.GetInstanceHealthinessInput) (*aws.GetInstanceHealthinessOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) ImportBeanstalkEnv(context.Context, *aws.ImportBeanstalkInput) (*aws.ImportBeanstalkOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) StopDeployment(context.Context, *aws.StopDeploymentInput) (*aws.StopDeploymentOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) Update(ctx context.Context, input *aws.UpdateGroupInput) (*aws.UpdateGroupOutput, error) {
+	args := s.Called(ctx, input)
+	return args.Get(0).(*aws.UpdateGroupOutput), nil
+}
+
+func (s *awsServiceMock) Delete(ctx context.Context, input *aws.DeleteGroupInput) (*aws.DeleteGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) Status(ctx context.Context, input *aws.StatusGroupInput) (*aws.StatusGroupOutput, error) {
+	out := &aws.StatusGroupOutput{
+		Instances: []*aws.Instance{
+			{
+				ID: spotinst.String("test-instance-id"),
+			},
+			{
+				ID: spotinst.String("second-test-instance-id"),
+			},
+		},
+	}
+	return out, nil
+}
+
+func (s *awsServiceMock) Detach(ctx context.Context, input *aws.DetachGroupInput) (*aws.DetachGroupOutput, error) {
+	args := s.Called(ctx, input)
+	return args.Get(0).(*aws.DetachGroupOutput), nil
+}
+
+func (s *awsServiceMock) Roll(ctx context.Context, input *aws.RollGroupInput) (*aws.RollGroupOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) CreateSuspensions(ctx context.Context, input *aws.CreateSuspensionsInput) (*aws.CreateSuspensionsOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) ListSuspensions(context.Context, *aws.ListSuspensionsInput) (*aws.ListSuspensionsOutput, error) {
+	return nil, nil
+}
+func (s *awsServiceMock) DeleteSuspensions(context.Context, *aws.DeleteSuspensionsInput) (*aws.DeleteSuspensionsOutput, error) {
+	return nil, nil
+}
+
+func (s *awsServiceMock) ListStatefulInstances(context.Context, *aws.ListStatefulInstancesInput) (*aws.ListStatefulInstancesOutput, error) {
+	return nil, nil
+}
+func (s *awsServiceMock) PauseStatefulInstance(context.Context, *aws.PauseStatefulInstanceInput) (*aws.PauseStatefulInstanceOutput, error) {
+	return nil, nil
+}
+func (s *awsServiceMock) ResumeStatefulInstance(context.Context, *aws.ResumeStatefulInstanceInput) (*aws.ResumeStatefulInstanceOutput, error) {
+	return nil, nil
+}
+func (s *awsServiceMock) RecycleStatefulInstance(context.Context, *aws.RecycleStatefulInstanceInput) (*aws.RecycleStatefulInstanceOutput, error) {
+	return nil, nil
+}
+func (s *awsServiceMock) DeallocateStatefulInstance(context.Context, *aws.DeallocateStatefulInstanceInput) (*aws.DeallocateStatefulInstanceOutput, error) {
+	return nil, nil
+}
+
+func testCloudManager(t *testing.T) *CloudManager {
+	return &CloudManager{
+		groupService: &groupServiceMock{
+			providerAWS: new(awsServiceMock),
+		},
+		groups:          make([]*Group, 0),
+		cache:           make(map[string]*Group),
+		interruptCh:     make(chan struct{}),
+		refreshInterval: time.Minute,
+	}
+}
+
+func testCloudProvider(t *testing.T, m *CloudManager) *CloudProvider {
+	resourceLimiter := cloudprovider.NewResourceLimiter(
+		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
+		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
+
+	cloud, err := NewCloudProvider(m, resourceLimiter)
+	assert.NoError(t, err)
+	return cloud
+}
+
+func TestNewCloudProvider(t *testing.T) {
+	testCloudProvider(t, testCloudManager(t))
+}
+
+func TestAddNodeGroup(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("bad spec")
+	assert.Error(t, err)
+	assert.Equal(t, len(provider.manager.groups), 0)
+
+	err = provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.manager.groups), 1)
+}
+
+func TestName(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	assert.Equal(t, provider.Name(), "spotinst")
+}
+
+func TestNodeGroups(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	assert.Equal(t, len(provider.NodeGroups()), 0)
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.NodeGroups()), 1)
+}
+
+func TestNodeGroupForNode(t *testing.T) {
+	node := &apiv1.Node{
+		Spec: apiv1.NodeSpec{
+			ProviderID: "aws:///us-east-1a/test-instance-id",
+		},
+	}
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	group, err := provider.NodeGroupForNode(node)
+
+	assert.NoError(t, err)
+	assert.Equal(t, group.Id(), "sig-test")
+	assert.Equal(t, group.MinSize(), 1)
+	assert.Equal(t, group.MaxSize(), 5)
+
+	// test node in cluster that is not in a group managed by cluster autoscaler
+	nodeNotInGroup := &apiv1.Node{
+		Spec: apiv1.NodeSpec{
+			ProviderID: "aws:///us-east-1a/test-instance-id-not-in-group",
+		},
+	}
+
+	group, err = provider.NodeGroupForNode(nodeNotInGroup)
+	assert.NoError(t, err)
+	assert.Nil(t, group)
+}
+
+func TestExtractInstanceId(t *testing.T) {
+	_, err := extractInstanceId("bad spec")
+	assert.Error(t, err)
+
+	instanceID, err := extractInstanceId("aws:///us-east-1a/i-260942b3")
+	assert.NoError(t, err)
+	assert.Equal(t, instanceID, "i-260942b3")
+}
+
+func TestMaxSize(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.manager.groups), 1)
+	assert.Equal(t, provider.manager.groups[0].MaxSize(), 5)
+}
+
+func TestMinSize(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.manager.groups), 1)
+	assert.Equal(t, provider.manager.groups[0].MinSize(), 1)
+}
+
+func TestTargetSize(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	targetSize, err := provider.manager.groups[0].TargetSize()
+	assert.Equal(t, targetSize, 2)
+	assert.NoError(t, err)
+}
+
+func TestIncreaseSize(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.manager.groups), 1)
+
+	cloud := provider.manager.groupService.CloudProviderAWS().(*awsServiceMock)
+	cloud.On("Update", context.Background(), &aws.UpdateGroupInput{
+		Group: &aws.Group{
+			ID: spotinst.String(provider.manager.groups[0].Id()),
+			Capacity: &aws.Capacity{
+				Target:  spotinst.Int(3),
+				Minimum: spotinst.Int(provider.manager.groups[0].minSize),
+				Maximum: spotinst.Int(provider.manager.groups[0].maxSize),
+			},
+		},
+	}).Return(&aws.UpdateGroupOutput{})
+
+	err = provider.manager.groups[0].IncreaseSize(1)
+	assert.NoError(t, err)
+	cloud.AssertExpectations(t)
+}
+
+func TestBelongs(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+
+	invalidNode := &apiv1.Node{
+		Spec: apiv1.NodeSpec{
+			ProviderID: "aws:///us-east-1a/invalid-instance-id",
+		},
+	}
+	_, err = provider.manager.groups[0].Belongs(invalidNode)
+	assert.Error(t, err)
+
+	validNode := &apiv1.Node{
+		Spec: apiv1.NodeSpec{
+			ProviderID: "aws:///us-east-1a/test-instance-id",
+		},
+	}
+	belongs, err := provider.manager.groups[0].Belongs(validNode)
+	assert.Equal(t, belongs, true)
+	assert.NoError(t, err)
+}
+
+func TestDeleteNodes(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.manager.groups), 1)
+
+	cloud := provider.manager.groupService.CloudProviderAWS().(*awsServiceMock)
+	cloud.On("Detach", context.Background(), &aws.DetachGroupInput{
+		GroupID:                       spotinst.String(provider.manager.groups[0].Id()),
+		InstanceIDs:                   []string{"test-instance-id"},
+		ShouldDecrementTargetCapacity: spotinst.Bool(true),
+		ShouldTerminateInstances:      spotinst.Bool(true),
+	}).Return(&aws.DetachGroupOutput{})
+
+	node := &apiv1.Node{
+		Spec: apiv1.NodeSpec{
+			ProviderID: "aws:///us-east-1a/test-instance-id",
+		},
+	}
+
+	err = provider.manager.groups[0].DeleteNodes([]*apiv1.Node{node})
+	assert.NoError(t, err)
+	cloud.AssertExpectations(t)
+}
+
+func TestId(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.manager.addNodeGroup("1:5:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, len(provider.manager.groups), 1)
+	assert.Equal(t, provider.manager.groups[0].Id(), "sig-test")
+}
+
+func TestDebug(t *testing.T) {
+	grp := Group{
+		manager: testCloudManager(t),
+		minSize: 5,
+		maxSize: 55,
+	}
+	grp.groupID = "sig-test"
+	assert.Equal(t, grp.Debug(), "sig-test (5:55)")
+}
+
+func TestBuildGroup(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+
+	_, err := provider.manager.buildGroupFromSpec("a")
+	assert.Error(t, err)
+	_, err = provider.manager.buildGroupFromSpec("a:b:c")
+	assert.Error(t, err)
+	_, err = provider.manager.buildGroupFromSpec("1:")
+	assert.Error(t, err)
+	_, err = provider.manager.buildGroupFromSpec("1:2:")
+	assert.Error(t, err)
+
+	grp, err := provider.manager.buildGroupFromSpec("111:222:sig-test")
+	assert.NoError(t, err)
+	assert.Equal(t, 111, grp.MinSize())
+	assert.Equal(t, 222, grp.MaxSize())
+	assert.Equal(t, "sig-test", grp.Id())
+}
+
+func TestGetResourceLimiter(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	_, err := provider.GetResourceLimiter()
+	assert.NoError(t, err)
+}
+
+func TestCleanup(t *testing.T) {
+	provider := testCloudProvider(t, testCloudManager(t))
+	err := provider.Cleanup()
+	assert.NoError(t, err)
+}
diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go
new file mode 100644
index 000000000..9f1ed24e9
--- /dev/null
+++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go
@@ -0,0 +1,510 @@
+/*
+Copyright 2016 The Kubernetes Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package spotinst
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"io"
+	"k8s.io/autoscaler/cluster-autoscaler/utils/gpu"
+	"k8s.io/klog"
+	"math/rand"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+
+	"k8s.io/autoscaler/cluster-autoscaler/utils/mpscontext"
+
+	"github.com/spotinst/spotinst-sdk-go/service/elastigroup"
+	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
+	"github.com/spotinst/spotinst-sdk-go/spotinst"
+	"github.com/spotinst/spotinst-sdk-go/spotinst/log"
+	"github.com/spotinst/spotinst-sdk-go/spotinst/session"
+	"github.com/spotinst/spotinst-sdk-go/spotinst/util/stringutil"
+	apiv1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/util/wait"
+	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
+	"k8s.io/autoscaler/cluster-autoscaler/utils/gpumemory"
+	kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
+	gcfg "gopkg.in/gcfg.v1"
+)
+
+// CloudManager holds the config and client.
+type CloudManager struct {
+	groupService    elastigroup.Service
+	groups          []*Group
+	refreshedAt     time.Time
+	refreshInterval time.Duration
+	interruptCh     chan struct{}
+	cacheMu         sync.Mutex
+	cache           map[string]*Group // k: InstanceID, v: Group
+}
+
+// CloudConfig holds the configuration parsed from the --cloud-config flag.
+// All fields are required unless otherwise specified.
+type CloudConfig struct {
+	Global struct{}
+}
+
+// NewCloudManager constructs manager object.
+func NewCloudManager(config io.Reader, discoveryOpts cloudprovider.NodeGroupDiscoveryOptions) (*CloudManager, error) {
+	klog.Info("Building Spotinst cloud manager")
+
+	cfg, err := readCloudConfig(config)
+	if err != nil {
+		return nil, err
+	}
+
+	svc, err := newService(cfg)
+	if err != nil {
+		return nil, err
+	}
+
+	manager := &CloudManager{
+		groupService:    svc,
+		refreshInterval: time.Minute,
+		interruptCh:     make(chan struct{}),
+		groups:          make([]*Group, 0),
+		cache:           make(map[string]*Group),
+	}
+
+	if err := manager.addNodeGroups(discoveryOpts.NodeGroupSpecs); err != nil {
+		return nil, err
+	}
+
+	go wait.Until(func() {
+		manager.cacheMu.Lock()
+		defer manager.cacheMu.Unlock()
+
+		if err := manager.forceRefresh(); err != nil {
+			klog.Errorf("Error while refreshing cache: %v", err)
+		}
+	}, time.Hour, manager.interruptCh)
+
+	return manager, nil
+}
+
+// newService returns a new instance of Spotinst Service.
+func newService(cloudConfig *CloudConfig) (elastigroup.Service, error) {
+	// Create a new config.
+	config := spotinst.DefaultConfig()
+	config.WithLogger(newStdLogger())
+	config.WithUserAgent("Kubernetes-ClusterAutoscaler")
+
+	// Create a new session.
+	sess := session.New(config)
+
+	// Create a new service.
+	svc := elastigroup.New(sess)
+
+	return svc, nil
+}
+
+func newStdLogger() log.Logger {
+	return log.LoggerFunc(func(format string, args ...interface{}) {
+		klog.V(4).Infof(format, args...)
+	})
+}
+
+// readCloudConfig reads an instance of Config from config reader.
+func readCloudConfig(config io.Reader) (*CloudConfig, error) {
+	var cfg CloudConfig
+
+	if config != nil {
+		if err := gcfg.ReadInto(&cfg, config); err != nil {
+			return nil, fmt.Errorf("couldn't read Spotinst config: %v", err)
+		}
+	}
+
+	return &cfg, nil
+}
+
+func (mgr *CloudManager) addNodeGroups(specs []string) error {
+	klog.Info("Attempting to add node groups")
+
+	for _, spec := range specs {
+		if err := mgr.addNodeGroup(spec); err != nil {
+			return fmt.Errorf("could not register group with spec %s: %v", spec, err)
+		}
+	}
+
+	return nil
+}
+
+func (mgr *CloudManager) addNodeGroup(spec string) error {
+	klog.Infof("Attempting to add node group: %s", spec)
+
+	group, err := mgr.buildGroupFromSpec(spec)
+	if err != nil {
+		return fmt.Errorf("could not parse spec for node group: %v", err)
+	}
+	err = mgr.RegisterGroup(group)
+	if err != nil {
+		return fmt.Errorf("could not register the group(%s): %v", group.Id(), err)
+	}
+
+	klog.Infof("Node group added: %s", group.groupID)
+	return nil
+}
+
+func (mgr *CloudManager) buildGroupFromSpec(value string) (*Group, error) {
+	spec, err := dynamic.SpecFromString(value, true)
+	if err != nil {
+		return nil, fmt.Errorf("failed to parse node group spec: %v", err)
+	}
+	group := &Group{
+		manager: mgr,
+		groupID: spec.Name,
+		minSize: spec.MinSize,
+		maxSize: spec.MaxSize,
+	}
+	return group, nil
+}
+
+// RegisterGroup registers a resource group in Spotinst Manager.
+func (mgr *CloudManager) RegisterGroup(grp *Group) error {
+	mgr.cacheMu.Lock()
+	defer mgr.cacheMu.Unlock()
+
+	group, err := mgr.getResourceForGroup(grp.Id())
+	if err != nil {
+		return err
+	}
+	grp.group = group
+
+	mgr.groups = append(mgr.groups, grp)
+	return nil
+}
+
+// GetGroupSize gets the current size of the group.
+func (mgr *CloudManager) GetGroupSize(grp *Group) (int64, error) {
+	group, err := mgr.getResourceForGroup(grp.Id())
+	if err != nil {
+		return -1, err
+	}
+	size := spotinst.IntValue(group.Capacity.Target)
+	return int64(size), nil
+}
+
+// SetGroupSize sets the instances count in a Group by updating a
+// predefined Spotinst stack parameter (specified by the user).
+func (mgr *CloudManager) SetGroupSize(grp *Group, size int64) error {
+	in := &aws.UpdateGroupInput{
+		Group: &aws.Group{
+			ID: spotinst.String(grp.Id()),
+			Capacity: &aws.Capacity{
+				Target:  spotinst.Int(int(size)),
+				Minimum: spotinst.Int(grp.minSize),
+				Maximum: spotinst.Int(grp.maxSize),
+			},
+		},
+	}
+	_, err := mgr.groupService.CloudProviderAWS().Update(context.Background(), in)
+	if err != nil {
+		return err
+	}
+	return nil
+}
+
+// GetGroupForInstance retrieves the resource group that contains
+// a given instance.
+func (mgr *CloudManager) GetGroupForInstance(instanceID string) (*Group, error) {
+	mgr.cacheMu.Lock()
+	defer mgr.cacheMu.Unlock()
+
+	if group, ok := mgr.cache[instanceID]; ok {
+		return group, nil
+	}
+
+	if err := mgr.forceRefresh(); err != nil {
+		return nil, err
+	}
+
+	if group, ok := mgr.cache[instanceID]; ok {
+		return group, nil
+	}
+
+	klog.Warningf("Instance `%s` does not belong to any managed group", instanceID)
+	return nil, nil
+}
+
+// DeleteInstances deletes the specified instances from the
+// OpenStack resource group
+func (mgr *CloudManager) DeleteInstances(instanceIDs []string) error {
+	if len(instanceIDs) == 0 {
+		return nil
+	}
+	commonGroup, err := mgr.GetGroupForInstance(instanceIDs[0])
+	if err != nil {
+		return err
+	}
+	for _, instanceID := range instanceIDs {
+		instanceGroup, err := mgr.GetGroupForInstance(instanceID)
+		if err != nil {
+			return err
+		}
+		if instanceGroup.groupID != commonGroup.groupID {
+			return errors.New("connot delete instances which don't belong to the same group")
+		}
+	}
+	in := &aws.DetachGroupInput{
+		GroupID:                       spotinst.String(commonGroup.groupID),
+		InstanceIDs:                   instanceIDs,
+		ShouldDecrementTargetCapacity: spotinst.Bool(true),
+		ShouldTerminateInstances:      spotinst.Bool(true),
+	}
+	if _, err := mgr.groupService.CloudProviderAWS().Detach(context.Background(), in); err != nil {
+		return fmt.Errorf("failed to detach instances from group %s: %v", commonGroup.groupID, err)
+	}
+	return nil
+}
+
+func (mgr *CloudManager) getResourceForGroup(groupID string) (*aws.Group, error) {
+	in := &aws.ReadGroupInput{
+		GroupID: spotinst.String(groupID),
+	}
+	out, err := mgr.groupService.CloudProviderAWS().Read(context.Background(), in)
+	if err != nil {
+		return nil, err
+	}
+	if out.Group == nil {
+		return nil, fmt.Errorf("failed to get group %s", groupID)
+	}
+	return out.Group, nil
+}
+
+// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.
+func (mgr *CloudManager) Cleanup() error {
+	close(mgr.interruptCh)
+	return nil
+}
+
+// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
+// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
+func (mgr *CloudManager) Refresh() error {
+	mgr.cacheMu.Lock()
+	defer mgr.cacheMu.Unlock()
+
+	if mgr.refreshedAt.Add(mgr.refreshInterval).After(time.Now()) {
+		return nil
+	}
+	return mgr.forceRefresh()
+}
+
+func (mgr *CloudManager) forceRefresh() error {
+	mgr.regenerateCache()
+	mgr.refreshedAt = time.Now()
+	klog.V(2).Infof("Refreshed, next refresh after %v", mgr.refreshedAt.Add(mgr.refreshInterval))
+	return nil
+}
+
+func (mgr *CloudManager) regenerateCache() {
+	mgr.cache = make(map[string]*Group)
+	for _, group := range mgr.groups {
+		klog.V(4).Infof("Regenerating resource group information for %s", group.groupID)
+		if err := mgr.refreshGroupNodes(group); err != nil {
+			klog.Warningf("Could not retrieve nodes for group %s: %v", group.groupID, err)
+		}
+	}
+}
+
+func (mgr *CloudManager) refreshGroupNodes(grp *Group) error {
+	in := &aws.StatusGroupInput{
+		GroupID: spotinst.String(grp.Id()),
+	}
+	status, err := mgr.groupService.CloudProviderAWS().Status(context.Background(), in)
+	if err != nil {
+		return err
+	}
+	for _, instance := range status.Instances {
+		if instance.ID != nil {
+			instanceID := spotinst.StringValue(instance.ID)
+			klog.Infof("Managing AWS instance with ID %s in group %s", instanceID, grp.Id())
+			mgr.cache[instanceID] = grp
+		}
+	}
+	return nil
+}
+
+type groupTemplate struct {
+	InstanceType *instanceType
+	Region       string
+	Zone         string
+	Tags         []*aws.Tag
+}
+
+func (mgr *CloudManager) inferInstanceType(instanceTypeName string) *instanceType {
+	ret := &instanceType{
+		InstanceType: instanceTypeName,
+		VCPU:         1,
+		MemoryMb:     1024, // 1GB
+		GPU:          0,
+	}
+	size := 1
+	if strings.HasSuffix(instanceTypeName, ".medium") || strings.HasSuffix(instanceTypeName, ".large") {
+		size = 1
+	} else if strings.HasSuffix(instanceTypeName, ".xlarge") {
+		size = 2
+	} else {
+		elems := strings.Split(instanceTypeName, ".")
+		if len(elems) > 1 {
+			nums := strings.Split(elems[1], "xlarge")
+			if len(nums) > 0 {
+				if num, err := strconv.Atoi(nums[0]); err == nil {
+					size = num * 2
+				}
+			}
+		}
+	}
+	ret.VCPU = 2 * int64(size)
+	ret.MemoryMb = 1024 * 2 * ret.VCPU
+	if strings.HasPrefix(instanceTypeName, "g") || strings.HasPrefix(instanceTypeName, "p") {
+		ret.GPU = int64(size / 4)
+		if ret.GPU <= 0 {
+			ret.GPU = 1
+		}
+	}
+	return ret
+}
+
+func (mgr *CloudManager) buildGroupTemplate(groupID string) (*groupTemplate, error) {
+	klog.Infof("Building template for group %s", groupID)
+
+	group, err := mgr.getResourceForGroup(groupID)
+	if err != nil {
+		return nil, err
+	}
+
+	if len(group.Compute.AvailabilityZones) < 1 {
+		return nil, fmt.Errorf("unable to get first AvailabilityZone for %s", groupID)
+	}
+
+	zone := spotinst.StringValue(group.Compute.AvailabilityZones[0].Name)
+	region := zone[0 : len(zone)-1]
+
+	if len(group.Compute.AvailabilityZones) > 1 {
+		klog.Warningf("Found multiple availability zones, using %s", zone)
+	}
+
+	instanceTypeName := spotinst.StringValue(group.Compute.InstanceTypes.OnDemand)
+	foundInstanceType := InstanceTypes[instanceTypeName]
+	if foundInstanceType == nil {
+		klog.Warningf("Unable to get node template info for instance type %s", instanceTypeName)
+		foundInstanceType = mgr.inferInstanceType(instanceTypeName)
+	}
+
+	tmpl := &groupTemplate{
+		InstanceType: foundInstanceType,
+		Region:       region,
+		Zone:         zone,
+		Tags:         group.Compute.LaunchSpecification.Tags,
+	}
+
+	return tmpl, nil
+}
+
+func (mgr *CloudManager) buildNodeFromTemplate(group *Group, template *groupTemplate) (*apiv1.Node, error) {
+	klog.Infof("Building node from template of group %s", group.Id())
+
+	node := apiv1.Node{}
+	nodeName := fmt.Sprintf("%s-group-%d", group.groupID, rand.Int63())
+
+	node.ObjectMeta = metav1.ObjectMeta{
+		Name:     nodeName,
+		SelfLink: fmt.Sprintf("/api/v1/nodes/%s", nodeName),
+		Labels:   map[string]string{},
+	}
+
+	node.Status = apiv1.NodeStatus{
+		Capacity: apiv1.ResourceList{},
+	}
+
+	node.Status.Capacity[apiv1.ResourcePods] = *resource.NewQuantity(110, resource.DecimalSI)
+	node.Status.Capacity[apiv1.ResourceCPU] = *resource.NewQuantity(template.InstanceType.VCPU, resource.DecimalSI)
+	node.Status.Capacity[apiv1.ResourceMemory] = *resource.NewQuantity(template.InstanceType.MemoryMb*1024*1024, resource.DecimalSI)
+	node.Status.Capacity[gpu.ResourceNvidiaGPU] = *resource.NewQuantity(template.InstanceType.GPU, resource.DecimalSI)
+	node.Status.Capacity[gpumemory.ResourceVisenzeGPUMemory] = *resource.NewQuantity(template.InstanceType.GPUMemory, resource.DecimalSI)
+	node.Status.Capacity[mpscontext.ResourceVisenzeMPSContext] = *resource.NewQuantity(template.InstanceType.MPSContext, resource.DecimalSI)
+	node.Status.Allocatable = node.Status.Capacity
+
+	// NodeLabels
+	node.Labels = cloudprovider.JoinStringMaps(node.Labels, extractLabelsFromGroup(template.Tags))
+
+	// GenericLabels
+	node.Labels = cloudprovider.JoinStringMaps(node.Labels, buildGenericLabels(template, nodeName))
+
+	node.Spec.Taints = extractTaintsFromGroup(template.Tags)
+	node.Status.Conditions = cloudprovider.BuildReadyConditions()
+
+	klog.V(4).Infof("Node `%s` labels: %s", nodeName, stringutil.Stringify(node.Labels))
+	klog.V(4).Infof("Node `%s` taints: %s", nodeName, stringutil.Stringify(node.Spec.Taints))
+
+	return &node, nil
+}
+
+func buildGenericLabels(template *groupTemplate, nodeName string) map[string]string {
+	result := make(map[string]string)
+
+	result[kubeletapis.LabelArch] = cloudprovider.DefaultArch
+	result[kubeletapis.LabelOS] = cloudprovider.DefaultOS
+	result[apiv1.LabelInstanceType] = template.InstanceType.InstanceType
+	result[apiv1.LabelZoneRegion] = template.Region
+	result[apiv1.LabelZoneFailureDomain] = template.Zone
+	result[apiv1.LabelHostname] = nodeName
+
+	return result
+}
+
+func extractLabelsFromGroup(tags []*aws.Tag) map[string]string {
+	result := make(map[string]string)
+
+	for _, tag := range tags {
+		k := *tag.Key
+		v := *tag.Value
+		splits := strings.Split(k, "k8s.io/cluster-autoscaler/node-template/label/")
+		if len(splits) > 1 {
+			label := splits[1]
+			if label != "" {
+				result[label] = v
+			}
+		}
+	}
+
+	return result
+}
+
+func extractTaintsFromGroup(tags []*aws.Tag) []apiv1.Taint {
+	taints := make([]apiv1.Taint, 0)
+
+	for _, tag := range tags {
+		k := *tag.Key
+		v := *tag.Value
+		splits := strings.Split(k, "k8s.io/cluster-autoscaler/node-template/taint/")
+		if len(splits) > 1 {
+			values := strings.SplitN(v, ":", 2)
+			taints = append(taints, apiv1.Taint{
+				Key:    splits[1],
+				Value:  values[0],
+				Effect: apiv1.TaintEffect(values[1]),
+			})
+		}
+	}
+
+	return taints
+}
diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go
new file mode 100644
index 000000000..648a559ad
--- /dev/null
+++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go
@@ -0,0 +1,225 @@
+/*
+Copyright 2016 The Kubernetes Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package spotinst
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"k8s.io/klog"
+	"regexp"
+	"strings"
+
+	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
+	"github.com/spotinst/spotinst-sdk-go/spotinst"
+	apiv1 "k8s.io/api/core/v1"
+	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+	"k8s.io/kubernetes/pkg/scheduler/nodeinfo"
+)
+
+type Group struct {
+	manager *CloudManager
+	group   *aws.Group
+	groupID string
+	minSize int
+	maxSize int
+}
+
+// MaxSize returns maximum size of the node group.
+func (grp *Group) MaxSize() int {
+	return grp.maxSize
+}
+
+// MinSize returns minimum size of the node group.
+func (grp *Group) MinSize() int {
+	return grp.minSize
+}
+
+// TargetSize returns the current target size of the node group.
+func (grp *Group) TargetSize() (int, error) {
+	size, err := grp.manager.GetGroupSize(grp)
+	return int(size), err
+}
+
+// IncreaseSize increases the size of the node group.
+func (grp *Group) IncreaseSize(delta int) error {
+	if delta <= 0 {
+		return errors.New("size increase must be positive")
+	}
+	size, err := grp.manager.GetGroupSize(grp)
+	if err != nil {
+		return err
+	}
+	if int(size)+delta > grp.MaxSize() {
+		return fmt.Errorf("size increase too large - desired:%d max:%d", int(size)+delta, grp.MaxSize())
+	}
+	return grp.manager.SetGroupSize(grp, size+int64(delta))
+}
+
+// DeleteNodes deletes nodes from this node group.
+func (grp *Group) DeleteNodes(nodes []*apiv1.Node) error {
+	size, err := grp.manager.GetGroupSize(grp)
+	if err != nil {
+		return fmt.Errorf("error when deleting nodes, retrieving size of group %s failed: %v", grp.Id(), err)
+	}
+	if int(size) <= grp.MinSize() {
+		return errors.New("min size reached, nodes will not be deleted")
+	}
+	toBeDeleted := make([]string, 0)
+	for _, node := range nodes {
+		belongs, err := grp.Belongs(node)
+		if err != nil {
+			return fmt.Errorf("failed to check membership of node %s in group %s: %v", node.Name, grp.Id(), err)
+		}
+		if !belongs {
+			return fmt.Errorf("%s belongs to a different group than %s", node.Name, grp.Id())
+		}
+		instanceID, err := extractInstanceId(node.Spec.ProviderID)
+		if err != nil {
+			return fmt.Errorf("node %s's cloud provider ID is malformed: %v", node.Name, err)
+		}
+		toBeDeleted = append(toBeDeleted, instanceID)
+	}
+	return grp.manager.DeleteInstances(toBeDeleted)
+}
+
+// DecreaseTargetSize decreases the target size of the node group.
+func (grp *Group) DecreaseTargetSize(delta int) error {
+	if delta >= 0 {
+		return errors.New("size decrease size must be negative")
+	}
+	size, err := grp.manager.GetGroupSize(grp)
+	if err != nil {
+		return err
+	}
+	nodes, err := grp.Nodes()
+	if err != nil {
+		return err
+	}
+	if int(size)+delta < len(nodes) {
+		return fmt.Errorf("size decrease too large - desired:%d existing:%d", int(size)+delta, len(nodes))
+	}
+	return grp.manager.SetGroupSize(grp, size+int64(delta))
+}
+
+// Id returns an unique identifier of the node group.
+func (grp *Group) Id() string {
+	return grp.groupID
+}
+
+// Debug returns a string containing all information regarding this node group.
+func (grp *Group) Debug() string {
+	return fmt.Sprintf("%s (%d:%d)", grp.Id(), grp.MinSize(), grp.MaxSize())
+}
+
+// Nodes returns a list of all nodes that belong to this node group.
+func (grp *Group) Nodes() ([]cloudprovider.Instance, error) {
+	in := &aws.StatusGroupInput{
+		GroupID: spotinst.String(grp.Id()),
+	}
+	status, err := grp.manager.groupService.CloudProviderAWS().Status(context.Background(), in)
+	if err != nil {
+		return []cloudprovider.Instance{}, err
+	}
+	out := make([]cloudprovider.Instance, 0)
+	for _, instance := range status.Instances {
+		if instance.ID != nil && instance.AvailabilityZone != nil {
+			out = append(out, cloudprovider.Instance{Id: fmt.Sprintf("aws:///%s/%s", *instance.AvailabilityZone, *instance.ID)})
+		}
+	}
+	return out, nil
+}
+
+// TemplateNodeInfo returns a node template for this node group.
+func (grp *Group) TemplateNodeInfo() (*nodeinfo.NodeInfo, error) {
+	klog.Infof("No working nodes in node group %s, trying to generate from template", grp.Id())
+
+	template, err := grp.manager.buildGroupTemplate(grp.Id())
+	if err != nil {
+		return nil, err
+	}
+
+	node, err := grp.manager.buildNodeFromTemplate(grp, template)
+	if err != nil {
+		return nil, err
+	}
+
+	nodeInfo := nodeinfo.NewNodeInfo(cloudprovider.BuildKubeProxy(grp.Id()))
+	nodeInfo.SetNode(node)
+	return nodeInfo, nil
+}
+
+// Belongs returns true if the given node belongs to the NodeGroup.
+func (grp *Group) Belongs(node *apiv1.Node) (bool, error) {
+	instanceID, err := extractInstanceId(node.Spec.ProviderID)
+	if err != nil {
+		return false, err
+	}
+	group, err := grp.manager.GetGroupForInstance(instanceID)
+	if err != nil {
+		return false, err
+	}
+	if group == nil {
+		return false, fmt.Errorf("%s does not belong to a known group", node.Name)
+	}
+	return true, nil
+}
+
+// Exist checks if the node group really exists on the cloud provider side.
+func (grp *Group) Exist() bool {
+	return true
+}
+
+// Create creates the node group on the cloud provider side.
+func (grp *Group) Create() (cloudprovider.NodeGroup, error) {
+	return nil, cloudprovider.ErrAlreadyExist
+}
+
+// Delete deletes the node group on the cloud provider side.
+func (grp *Group) Delete() error {
+	return cloudprovider.ErrNotImplemented
+}
+
+// Autoprovisioned returns true if the node group is autoprovisioned.
+func (grp *Group) Autoprovisioned() bool {
+	return false
+}
+
+var (
+	spotinstProviderRE = regexp.MustCompile(`^spotinst\:\/\/\/[-0-9a-z]*\/[-0-9a-z]*$`)
+	awsProviderRE      = regexp.MustCompile(`^aws\:\/\/\/[-0-9a-z]*\/[-0-9a-z]*$`)
+)
+
+func extractInstanceId(providerID string) (string, error) {
+	var prefix string
+
+	if spotinstProviderRE.FindStringSubmatch(providerID) != nil {
+		prefix = "spotinst:///"
+	}
+
+	if awsProviderRE.FindStringSubmatch(providerID) != nil {
+		prefix = "aws:///"
+	}
+
+	if prefix == "" {
+		return "", fmt.Errorf("expected node provider ID to be one of the "+
+			"forms `spotinst:///<zone>/<instance-id>` or `aws:///<zone>/<instance-id>`, got `%s`", providerID)
+	}
+
+	parts := strings.Split(providerID[len(prefix):], "/")
+	instanceID := parts[1]
+
+	klog.Infof("Instance ID `%s` extracted from provider `%s`", instanceID, providerID)
+	return instanceID, nil
+}
diff --git a/cluster-autoscaler/utils/gpumemory/gpumemory.go b/cluster-autoscaler/utils/gpumemory/gpumemory.go
new file mode 100644
index 000000000..74dad4198
--- /dev/null
+++ b/cluster-autoscaler/utils/gpumemory/gpumemory.go
@@ -0,0 +1,41 @@
+package gpumemory
+
+import (
+	apiv1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+)
+
+const (
+	// ResourceVisenzeGPUMemory is the name of the GPU Memory resource
+	ResourceVisenzeGPUMemory = "visenze.com/nvidia-gpu-memory"
+	// GPULabel is the label added to nodes with GPU resource by Visenze.
+	// If you're not scaling - this is probably the problem!
+	GPULabel = "accelerator"
+)
+
+// NodeHasGpuMemory returns true if a given node has GPU hardware
+func NodeHasGpuMemory(node *apiv1.Node) bool {
+	_, hasGpuLabel := node.Labels[GPULabel]
+	gpuAllocatable, hasGpuAllocatable := node.Status.Allocatable[ResourceVisenzeGPUMemory]
+	return hasGpuLabel || (hasGpuAllocatable && !gpuAllocatable.IsZero())
+}
+
+// PodRequestsGpuMemory returns true if a given pod has GPU Memory request
+func PodRequestsGpuMemory(pod *apiv1.Pod) bool {
+	for _, container := range pod.Spec.Containers {
+		if container.Resources.Requests != nil {
+			_, gpuMemoryFound := container.Resources.Requests[ResourceVisenzeGPUMemory]
+			if gpuMemoryFound {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// RequestInfo gives some information about hwo much GPU memory is needed
+type RequestInfo struct {
+	MaximumMemory resource.Quantity
+	TotalMemory   resource.Quantity
+	Pods          []*apiv1.Pod
+}
diff --git a/cluster-autoscaler/utils/gpumemory/gpumemory_test.go b/cluster-autoscaler/utils/gpumemory/gpumemory_test.go
new file mode 100644
index 000000000..a69db0687
--- /dev/null
+++ b/cluster-autoscaler/utils/gpumemory/gpumemory_test.go
@@ -0,0 +1,83 @@
+package gpumemory
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+	apiv1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+func TestNodeHasGpuMemory(t *testing.T) {
+	gpuLabels := map[string]string{
+		GPULabel: "nvidia-tesla-k80",
+	}
+	nodeGpuReady := &apiv1.Node{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:   "nodeGpuReady",
+			Labels: gpuLabels,
+		},
+		Status: apiv1.NodeStatus{
+			Capacity:    apiv1.ResourceList{},
+			Allocatable: apiv1.ResourceList{},
+		},
+	}
+	nodeGpuReady.Status.Allocatable[ResourceVisenzeGPUMemory] = *resource.NewQuantity(8e9, resource.DecimalSI)
+	nodeGpuReady.Status.Capacity[ResourceVisenzeGPUMemory] = *resource.NewQuantity(8e9, resource.DecimalSI)
+	assert.True(t, NodeHasGpuMemory(nodeGpuReady))
+
+	nodeGpuUnready := &apiv1.Node{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:   "nodeGpuUnready",
+			Labels: gpuLabels,
+		},
+		Status: apiv1.NodeStatus{
+			Capacity:    apiv1.ResourceList{},
+			Allocatable: apiv1.ResourceList{},
+		},
+	}
+	assert.True(t, NodeHasGpuMemory(nodeGpuUnready))
+
+	nodeNoGpu := &apiv1.Node{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:   "nodeNoGpu",
+			Labels: map[string]string{},
+		},
+		Status: apiv1.NodeStatus{
+			Capacity:    apiv1.ResourceList{},
+			Allocatable: apiv1.ResourceList{},
+		},
+	}
+	assert.False(t, NodeHasGpuMemory(nodeNoGpu))
+}
+
+func TestPodRequestsGpuMemory(t *testing.T) {
+	podNoGpu := &apiv1.Pod{
+		Spec: apiv1.PodSpec{
+			Containers: []apiv1.Container{
+				apiv1.Container{
+					Resources: apiv1.ResourceRequirements{
+						Requests: apiv1.ResourceList{
+							apiv1.ResourceCPU: *resource.NewQuantity(1, resource.DecimalSI),
+						},
+					},
+				},
+			},
+		},
+	}
+	podWithGpu := &apiv1.Pod{Spec: apiv1.PodSpec{Containers: []apiv1.Container{
+		apiv1.Container{
+			Resources: apiv1.ResourceRequirements{
+				Requests: apiv1.ResourceList{
+					apiv1.ResourceCPU:        *resource.NewQuantity(1, resource.DecimalSI),
+					ResourceVisenzeGPUMemory: *resource.NewQuantity(1, resource.DecimalSI),
+				},
+			},
+		},
+	}}}
+	podWithGpu.Spec.Containers[0].Resources.Requests[ResourceVisenzeGPUMemory] = *resource.NewQuantity(1, resource.DecimalSI)
+
+	assert.False(t, PodRequestsGpuMemory(podNoGpu))
+	assert.True(t, PodRequestsGpuMemory(podWithGpu))
+}
diff --git a/cluster-autoscaler/utils/mpscontext/mpscontext.go b/cluster-autoscaler/utils/mpscontext/mpscontext.go
new file mode 100644
index 000000000..f01157f47
--- /dev/null
+++ b/cluster-autoscaler/utils/mpscontext/mpscontext.go
@@ -0,0 +1,6 @@
+package mpscontext
+
+// Custom resource for NVIDIA MPS context
+const (
+	ResourceVisenzeMPSContext = "visenze.com/nvidia-mps-context"
+)
diff --git a/cluster-autoscaler/version/version.go b/cluster-autoscaler/version/version.go
index b74536f7e..392964340 100644
--- a/cluster-autoscaler/version/version.go
+++ b/cluster-autoscaler/version/version.go
@@ -17,4 +17,4 @@ limitations under the License.
 package version
 
 // ClusterAutoscalerVersion contains version of CA.
-const ClusterAutoscalerVersion = "1.17.4"
+const ClusterAutoscalerVersion = "1.17.5"
diff --git a/patch/1.17.patch b/patch/1.17.patch
new file mode 100644
index 000000000..62be54a61
--- /dev/null
+++ b/patch/1.17.patch
@@ -0,0 +1,6503 @@
+diff --git a/Jenkinsfile b/Jenkinsfile
+new file mode 100644
+index 000000000..bb612ed8b
+--- /dev/null
++++ b/Jenkinsfile
+@@ -0,0 +1,107 @@
++
++// throttle concurrent build
++properties([[$class: 'ThrottleJobProperty', categories: [], limitOneJobWithMatchingParams: false, maxConcurrentPerNode: 1, maxConcurrentTotal: 1, paramsToUseForLimit: '', throttleEnabled: true, throttleOption: 'project']])
++
++library(identifier: "visenze-lib@${params['VISENZE_LIB_BRANCH'] ?: 'master'}", changelog: false)
++
++pipeline {
++  agent {
++    label "${params.AGENT_LABEL ?: 'build'}"
++  }
++
++  options {
++    ansiColor('xterm')
++  }
++
++  stages {
++    stage('Checkout') {
++      steps {
++        checkout([
++          $class: 'GitSCM',
++          branches: scm.branches,
++          doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
++          extensions: [
++            [
++              $class: 'CloneOption',
++              noTags: true,
++              reference: '',
++              timeout: 60
++            ],
++            [
++              $class: 'SubmoduleOption',
++              disableSubmodules: false,
++              parentCredentials: true,
++              recursiveSubmodules: true,
++              trackingSubmodules: true,
++              reference: '',
++              timeout: 60
++            ],
++            [$class: 'CleanBeforeCheckout']
++          ],
++          userRemoteConfigs: scm.userRemoteConfigs
++        ])
++      }
++    }
++
++    stage('Test') {
++      when {
++        expression {
++          return canRun()
++        }
++      }
++      steps {
++        script {
++          dir('cluster-autoscaler') {
++            sh('make test-in-docker')
++          }
++        }
++      }
++    }
++
++    stage('Compile') {
++      when {
++        expression {
++          return canRun()
++        }
++      }
++      steps {
++        script {
++          dir('cluster-autoscaler') {
++            sh('make build-in-docker')
++          }
++        }
++      }
++    }
++
++    stage('Docker') {
++      when {
++        expression {
++          return canRun()
++        }
++      }
++      steps {
++        script {
++          dir('cluster-autoscaler') {
++            def version = sh(script: "grep ClusterAutoscalerVersion version/version.go",
++                             returnStdout: true).split('"')[-2]
++            def registry = 'visenze'
++            withEnv([
++              "REGISTRY=${registry}",
++              "TAG=${version}"
++            ]) {
++              sh('make make-image')
++              docker.withRegistry('', 'docker-hub-credential') {
++                def image = docker.image("${registry}/cluster-autoscaler:${version}")
++                image.push()
++              }
++            }
++          }
++        }
++      }
++    }
++  }
++}
++
++def canRun() {
++  return env.BRANCH_NAME.startsWith('release-') || env.BRANCH_NAME == 'master'
++} 
+diff --git a/cluster-autoscaler/Makefile b/cluster-autoscaler/Makefile
+index 21ed38ef5..91dd4d043 100644
+--- a/cluster-autoscaler/Makefile
++++ b/cluster-autoscaler/Makefile
+@@ -3,7 +3,7 @@ all: build
+ TAG?=dev
+ FLAGS=
+ LDFLAGS?=-s
+-ENVVAR=CGO_ENABLED=0 GO111MODULE=off
++ENVVAR=CGO_ENABLED=0 GO111MODULE=on
+ GOOS?=linux
+ REGISTRY?=staging-k8s.gcr.io
+ ifdef BUILD_TAGS
+@@ -29,7 +29,7 @@ build-binary: clean deps
+ 	$(ENVVAR) GOOS=$(GOOS) go build -o cluster-autoscaler ${LDFLAGS_FLAG} ${TAGS_FLAG}
+ 
+ test-unit: clean deps build
+-	GO111MODULE=off go test --test.short -race ./... ${TAGS_FLAG}
++	GO111MODULE=on go test --test.short -race ./... ${TAGS_FLAG}
+ 
+ dev-release: build-binary execute-release
+ 	@echo "Release ${TAG}${FOR_PROVIDER} completed"
+@@ -70,7 +70,7 @@ container: build-in-docker make-image
+ 	@echo "Created in-docker image ${TAG}${FOR_PROVIDER}"
+ 
+ test-in-docker: clean docker-builder
+-	docker run -v `pwd`:/gopath/src/k8s.io/autoscaler/cluster-autoscaler/ autoscaling-builder:latest bash -c 'cd /gopath/src/k8s.io/autoscaler/cluster-autoscaler && GO111MODULE=off go test -race ./... ${TAGS_FLAG}'
++	docker run -v `pwd`:/gopath/src/k8s.io/autoscaler/cluster-autoscaler/ autoscaling-builder:latest bash -c 'cd /gopath/src/k8s.io/autoscaler/cluster-autoscaler && go test -race ./... ${TAGS_FLAG}'
+ 
+ .PHONY: all deps build test-unit clean format execute-release dev-release docker-builder build-in-docker release generate
+ 
+diff --git a/cluster-autoscaler/cloudprovider/builder/builder_all.go b/cluster-autoscaler/cloudprovider/builder/builder_all.go
+index 37fa63c84..68f133e52 100644
+--- a/cluster-autoscaler/cloudprovider/builder/builder_all.go
++++ b/cluster-autoscaler/cloudprovider/builder/builder_all.go
+@@ -29,6 +29,7 @@ import (
+ 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/gce"
+ 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/magnum"
+ 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/packet"
++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/spotinst"
+ 	"k8s.io/autoscaler/cluster-autoscaler/config"
+ )
+ 
+@@ -41,6 +42,7 @@ var AvailableCloudProviders = []string{
+ 	cloudprovider.BaiducloudProviderName,
+ 	cloudprovider.MagnumProviderName,
+ 	cloudprovider.DigitalOceanProviderName,
++	cloudprovider.SpotinstProviderName,
+ 	clusterapi.ProviderName,
+ }
+ 
+@@ -67,6 +69,8 @@ func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGro
+ 		return packet.BuildPacket(opts, do, rl)
+ 	case clusterapi.ProviderName:
+ 		return clusterapi.BuildClusterAPI(opts, do, rl)
++    case cloudprovider.SpotinstProviderName:
++		return spotinst.BuildSpotinst(opts, do, rl)
+ 	}
+ 	return nil
+ }
+diff --git a/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go b/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go
+new file mode 100644
+index 000000000..62b1e1744
+--- /dev/null
++++ b/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go
+@@ -0,0 +1,39 @@
++// +build spotinst
++
++/*
++Copyright 2018 The Kubernetes Authors.
++Licensed under the Apache License, Version 2.0 (the "License");
++you may not use this file except in compliance with the License.
++You may obtain a copy of the License at
++    http://www.apache.org/licenses/LICENSE-2.0
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an "AS IS" BASIS,
++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++*/
++
++package builder
++
++import (
++"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
++"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/spotinst"
++"k8s.io/autoscaler/cluster-autoscaler/config"
++)
++
++// AvailableCloudProviders supported by the cloud provider builder.
++var AvailableCloudProviders = []string{
++	spotinst.ProviderName,
++}
++
++// DefaultCloudProvider for Spotinst-only build is spotinst.
++const DefaultCloudProvider = spotinst.ProviderName
++
++func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
++	switch opts.CloudProviderName {
++	case spotinst.ProviderName:
++		return spotinst.BuildSpotinst(opts, do, rl)
++	}
++
++	return nil
++}
+diff --git a/cluster-autoscaler/cloudprovider/cloud_provider.go b/cluster-autoscaler/cloudprovider/cloud_provider.go
+index d9d50d04b..c2cdb6df9 100644
+--- a/cluster-autoscaler/cloudprovider/cloud_provider.go
++++ b/cluster-autoscaler/cloudprovider/cloud_provider.go
+@@ -43,6 +43,8 @@ const (
+ 	MagnumProviderName = "magnum"
+ 	// KubemarkProviderName gets the provider name of kubemark
+ 	KubemarkProviderName = "kubemark"
++	// SpotinstProviderName gets the provider name of aws
++	SpotinstProviderName = "spotinst"
+ )
+ 
+ // CloudProvider contains configuration info and functions for interacting with
+diff --git a/cluster-autoscaler/cloudprovider/gce/templates.go b/cluster-autoscaler/cloudprovider/gce/templates.go
+index 8d261e97b..63a73a4ed 100644
+--- a/cluster-autoscaler/cloudprovider/gce/templates.go
++++ b/cluster-autoscaler/cloudprovider/gce/templates.go
+@@ -37,6 +37,10 @@ import (
+ // GceTemplateBuilder builds templates for GCE nodes.
+ type GceTemplateBuilder struct{}
+ 
++// TODO: This should be imported from sigs.k8s.io/gcp-compute-persistent-disk-csi-driver/pkg/common/constants.go
++// This key is applicable to both GCE and GKE
++const gceCSITopologyKeyZone = "topology.gke.io/zone"
++
+ func (t *GceTemplateBuilder) getAcceleratorCount(accelerators []*gce.AcceleratorConfig) int64 {
+ 	count := int64(0)
+ 	for _, accelerator := range accelerators {
+@@ -180,12 +184,16 @@ func BuildGenericLabels(ref GceRef, machineType string, nodeName string) (map[st
+ 	result[kubeletapis.LabelOS] = cloudprovider.DefaultOS
+ 
+ 	result[apiv1.LabelInstanceType] = machineType
++	result[apiv1.LabelInstanceTypeStable] = machineType
+ 	ix := strings.LastIndex(ref.Zone, "-")
+ 	if ix == -1 {
+ 		return nil, fmt.Errorf("unexpected zone: %s", ref.Zone)
+ 	}
+ 	result[apiv1.LabelZoneRegion] = ref.Zone[:ix]
++	result[apiv1.LabelZoneRegionStable] = ref.Zone[:ix]
+ 	result[apiv1.LabelZoneFailureDomain] = ref.Zone
++	result[apiv1.LabelZoneFailureDomainStable] = ref.Zone
++	result[gceCSITopologyKeyZone] = ref.Zone
+ 	result[apiv1.LabelHostname] = nodeName
+ 	return result, nil
+ }
+diff --git a/cluster-autoscaler/cloudprovider/gce/templates_test.go b/cluster-autoscaler/cloudprovider/gce/templates_test.go
+index e289dba5e..ea0b05a78 100644
+--- a/cluster-autoscaler/cloudprovider/gce/templates_test.go
++++ b/cluster-autoscaler/cloudprovider/gce/templates_test.go
+@@ -134,7 +134,10 @@ func TestBuildGenericLabels(t *testing.T) {
+ 		"n1-standard-8", "sillyname")
+ 	assert.Nil(t, err)
+ 	assert.Equal(t, "us-central1", labels[apiv1.LabelZoneRegion])
++	assert.Equal(t, "us-central1", labels[apiv1.LabelZoneRegionStable])
+ 	assert.Equal(t, "us-central1-b", labels[apiv1.LabelZoneFailureDomain])
++	assert.Equal(t, "us-central1-b", labels[apiv1.LabelZoneFailureDomainStable])
++	assert.Equal(t, "us-central1-b", labels[gceCSITopologyKeyZone])
+ 	assert.Equal(t, "sillyname", labels[apiv1.LabelHostname])
+ 	assert.Equal(t, "n1-standard-8", labels[apiv1.LabelInstanceType])
+ 	assert.Equal(t, cloudprovider.DefaultArch, labels[kubeletapis.LabelArch])
+diff --git a/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go b/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go
+new file mode 100644
+index 000000000..8f772e57e
+--- /dev/null
++++ b/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go
+@@ -0,0 +1,1510 @@
++/*
++Copyright 2017 The Kubernetes Authors.
++Licensed under the Apache License, Version 2.0 (the "License");
++you may not use this file except in compliance with the License.
++You may obtain a copy of the License at
++    http://www.apache.org/licenses/LICENSE-2.0
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an "AS IS" BASIS,
++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++*/
++
++// This file was generated by go generate; DO NOT EDIT
++
++package spotinst
++
++type instanceType struct {
++	InstanceType string
++	VCPU         int64
++	MemoryMb     int64
++	GPU          int64
++	GPUMemory    int64
++	MPSContext   int64
++}
++
++// InstanceTypes is a map of ec2 resources
++var InstanceTypes = map[string]*instanceType{
++	"a1": {
++		InstanceType: "a1",
++		VCPU:         16,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"a1.2xlarge": {
++		InstanceType: "a1.2xlarge",
++		VCPU:         8,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"a1.4xlarge": {
++		InstanceType: "a1.4xlarge",
++		VCPU:         16,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"a1.large": {
++		InstanceType: "a1.large",
++		VCPU:         2,
++		MemoryMb:     4096,
++		GPU:          0,
++	},
++	"a1.medium": {
++		InstanceType: "a1.medium",
++		VCPU:         1,
++		MemoryMb:     2048,
++		GPU:          0,
++	},
++	"a1.xlarge": {
++		InstanceType: "a1.xlarge",
++		VCPU:         4,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"c1.medium": {
++		InstanceType: "c1.medium",
++		VCPU:         2,
++		MemoryMb:     1740,
++		GPU:          0,
++	},
++	"c1.xlarge": {
++		InstanceType: "c1.xlarge",
++		VCPU:         8,
++		MemoryMb:     7168,
++		GPU:          0,
++	},
++	"c3": {
++		InstanceType: "c3",
++		VCPU:         32,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"c3.2xlarge": {
++		InstanceType: "c3.2xlarge",
++		VCPU:         8,
++		MemoryMb:     15360,
++		GPU:          0,
++	},
++	"c3.4xlarge": {
++		InstanceType: "c3.4xlarge",
++		VCPU:         16,
++		MemoryMb:     30720,
++		GPU:          0,
++	},
++	"c3.8xlarge": {
++		InstanceType: "c3.8xlarge",
++		VCPU:         32,
++		MemoryMb:     61440,
++		GPU:          0,
++	},
++	"c3.large": {
++		InstanceType: "c3.large",
++		VCPU:         2,
++		MemoryMb:     3840,
++		GPU:          0,
++	},
++	"c3.xlarge": {
++		InstanceType: "c3.xlarge",
++		VCPU:         4,
++		MemoryMb:     7680,
++		GPU:          0,
++	},
++	"c4": {
++		InstanceType: "c4",
++		VCPU:         36,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"c4.2xlarge": {
++		InstanceType: "c4.2xlarge",
++		VCPU:         8,
++		MemoryMb:     15360,
++		GPU:          0,
++	},
++	"c4.4xlarge": {
++		InstanceType: "c4.4xlarge",
++		VCPU:         16,
++		MemoryMb:     30720,
++		GPU:          0,
++	},
++	"c4.8xlarge": {
++		InstanceType: "c4.8xlarge",
++		VCPU:         36,
++		MemoryMb:     61440,
++		GPU:          0,
++	},
++	"c4.large": {
++		InstanceType: "c4.large",
++		VCPU:         2,
++		MemoryMb:     3840,
++		GPU:          0,
++	},
++	"c4.xlarge": {
++		InstanceType: "c4.xlarge",
++		VCPU:         4,
++		MemoryMb:     7680,
++		GPU:          0,
++	},
++	"c5": {
++		InstanceType: "c5",
++		VCPU:         72,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"c5.12xlarge": {
++		InstanceType: "c5.12xlarge",
++		VCPU:         48,
++		MemoryMb:     98304,
++		GPU:          0,
++	},
++	"c5.18xlarge": {
++		InstanceType: "c5.18xlarge",
++		VCPU:         72,
++		MemoryMb:     147456,
++		GPU:          0,
++	},
++	"c5.24xlarge": {
++		InstanceType: "c5.24xlarge",
++		VCPU:         96,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"c5.2xlarge": {
++		InstanceType: "c5.2xlarge",
++		VCPU:         8,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"c5.4xlarge": {
++		InstanceType: "c5.4xlarge",
++		VCPU:         16,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"c5.9xlarge": {
++		InstanceType: "c5.9xlarge",
++		VCPU:         36,
++		MemoryMb:     73728,
++		GPU:          0,
++	},
++	"c5.large": {
++		InstanceType: "c5.large",
++		VCPU:         2,
++		MemoryMb:     4096,
++		GPU:          0,
++	},
++	"c5.metal": {
++		InstanceType: "c5.metal",
++		VCPU:         96,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"c5.xlarge": {
++		InstanceType: "c5.xlarge",
++		VCPU:         4,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"c5d": {
++		InstanceType: "c5d",
++		VCPU:         72,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"c5d.18xlarge": {
++		InstanceType: "c5d.18xlarge",
++		VCPU:         72,
++		MemoryMb:     147456,
++		GPU:          0,
++	},
++	"c5d.2xlarge": {
++		InstanceType: "c5d.2xlarge",
++		VCPU:         8,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"c5d.4xlarge": {
++		InstanceType: "c5d.4xlarge",
++		VCPU:         16,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"c5d.9xlarge": {
++		InstanceType: "c5d.9xlarge",
++		VCPU:         36,
++		MemoryMb:     73728,
++		GPU:          0,
++	},
++	"c5d.large": {
++		InstanceType: "c5d.large",
++		VCPU:         2,
++		MemoryMb:     4096,
++		GPU:          0,
++	},
++	"c5d.xlarge": {
++		InstanceType: "c5d.xlarge",
++		VCPU:         4,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"c5n": {
++		InstanceType: "c5n",
++		VCPU:         72,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"c5n.18xlarge": {
++		InstanceType: "c5n.18xlarge",
++		VCPU:         72,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"c5n.2xlarge": {
++		InstanceType: "c5n.2xlarge",
++		VCPU:         8,
++		MemoryMb:     21504,
++		GPU:          0,
++	},
++	"c5n.4xlarge": {
++		InstanceType: "c5n.4xlarge",
++		VCPU:         16,
++		MemoryMb:     43008,
++		GPU:          0,
++	},
++	"c5n.9xlarge": {
++		InstanceType: "c5n.9xlarge",
++		VCPU:         36,
++		MemoryMb:     98304,
++		GPU:          0,
++	},
++	"c5n.large": {
++		InstanceType: "c5n.large",
++		VCPU:         2,
++		MemoryMb:     5376,
++		GPU:          0,
++	},
++	"c5n.xlarge": {
++		InstanceType: "c5n.xlarge",
++		VCPU:         4,
++		MemoryMb:     10752,
++		GPU:          0,
++	},
++	"cc2.8xlarge": {
++		InstanceType: "cc2.8xlarge",
++		VCPU:         32,
++		MemoryMb:     61952,
++		GPU:          0,
++	},
++	"cg1.4xlarge": {
++		InstanceType: "cg1.4xlarge",
++		VCPU:         16,
++		MemoryMb:     23040,
++		GPU:          0,
++	},
++	"cr1.8xlarge": {
++		InstanceType: "cr1.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"d2": {
++		InstanceType: "d2",
++		VCPU:         36,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"d2.2xlarge": {
++		InstanceType: "d2.2xlarge",
++		VCPU:         8,
++		MemoryMb:     62464,
++		GPU:          0,
++	},
++	"d2.4xlarge": {
++		InstanceType: "d2.4xlarge",
++		VCPU:         16,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"d2.8xlarge": {
++		InstanceType: "d2.8xlarge",
++		VCPU:         36,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"d2.xlarge": {
++		InstanceType: "d2.xlarge",
++		VCPU:         4,
++		MemoryMb:     31232,
++		GPU:          0,
++	},
++	"f1": {
++		InstanceType: "f1",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"f1.16xlarge": {
++		InstanceType: "f1.16xlarge",
++		VCPU:         64,
++		MemoryMb:     999424,
++		GPU:          0,
++	},
++	"f1.2xlarge": {
++		InstanceType: "f1.2xlarge",
++		VCPU:         8,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"f1.4xlarge": {
++		InstanceType: "f1.4xlarge",
++		VCPU:         16,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"g2": {
++		InstanceType: "g2",
++		VCPU:         32,
++		MemoryMb:     0,
++		GPU:          4,
++		MPSContext:   16,
++	},
++	"g2.2xlarge": {
++		InstanceType: "g2.2xlarge",
++		VCPU:         8,
++		MemoryMb:     15360,
++		GPU:          1,
++		MPSContext:   16,
++	},
++	"g2.8xlarge": {
++		InstanceType: "g2.8xlarge",
++		VCPU:         32,
++		MemoryMb:     61440,
++		GPU:          4,
++		MPSContext:   16,
++	},
++	"g3": {
++		InstanceType: "g3",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          4,
++		GPUMemory:    31931236352,
++		MPSContext:   16,
++	},
++	"g3.16xlarge": {
++		InstanceType: "g3.16xlarge",
++		VCPU:         64,
++		MemoryMb:     499712,
++		GPU:          4,
++		GPUMemory:    31931236352,
++		MPSContext:   16,
++	},
++	"g3.4xlarge": {
++		InstanceType: "g3.4xlarge",
++		VCPU:         16,
++		MemoryMb:     124928,
++		GPU:          1,
++		GPUMemory:    7982809088,
++		MPSContext:   16,
++	},
++	"g3.8xlarge": {
++		InstanceType: "g3.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          2,
++		GPUMemory:    15965618176,
++		MPSContext:   16,
++	},
++	"g3s.xlarge": {
++		InstanceType: "g3s.xlarge",
++		VCPU:         4,
++		MemoryMb:     31232,
++		GPU:          1,
++		GPUMemory:    7982809088,
++		MPSContext:   16,
++	},
++	"h1": {
++		InstanceType: "h1",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"h1.16xlarge": {
++		InstanceType: "h1.16xlarge",
++		VCPU:         64,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"h1.2xlarge": {
++		InstanceType: "h1.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"h1.4xlarge": {
++		InstanceType: "h1.4xlarge",
++		VCPU:         16,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"h1.8xlarge": {
++		InstanceType: "h1.8xlarge",
++		VCPU:         32,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"hs1.8xlarge": {
++		InstanceType: "hs1.8xlarge",
++		VCPU:         17,
++		MemoryMb:     119808,
++		GPU:          0,
++	},
++	"i2": {
++		InstanceType: "i2",
++		VCPU:         32,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"i2.2xlarge": {
++		InstanceType: "i2.2xlarge",
++		VCPU:         8,
++		MemoryMb:     62464,
++		GPU:          0,
++	},
++	"i2.4xlarge": {
++		InstanceType: "i2.4xlarge",
++		VCPU:         16,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"i2.8xlarge": {
++		InstanceType: "i2.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"i2.xlarge": {
++		InstanceType: "i2.xlarge",
++		VCPU:         4,
++		MemoryMb:     31232,
++		GPU:          0,
++	},
++	"i3": {
++		InstanceType: "i3",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"i3.16xlarge": {
++		InstanceType: "i3.16xlarge",
++		VCPU:         64,
++		MemoryMb:     499712,
++		GPU:          0,
++	},
++	"i3.2xlarge": {
++		InstanceType: "i3.2xlarge",
++		VCPU:         8,
++		MemoryMb:     62464,
++		GPU:          0,
++	},
++	"i3.4xlarge": {
++		InstanceType: "i3.4xlarge",
++		VCPU:         16,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"i3.8xlarge": {
++		InstanceType: "i3.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"i3.large": {
++		InstanceType: "i3.large",
++		VCPU:         2,
++		MemoryMb:     15616,
++		GPU:          0,
++	},
++	"i3.metal": {
++		InstanceType: "i3.metal",
++		VCPU:         72,
++		MemoryMb:     524288,
++		GPU:          0,
++	},
++	"i3.xlarge": {
++		InstanceType: "i3.xlarge",
++		VCPU:         4,
++		MemoryMb:     31232,
++		GPU:          0,
++	},
++	"i3en": {
++		InstanceType: "i3en",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"i3en.12xlarge": {
++		InstanceType: "i3en.12xlarge",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"i3en.24xlarge": {
++		InstanceType: "i3en.24xlarge",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"i3en.2xlarge": {
++		InstanceType: "i3en.2xlarge",
++		VCPU:         8,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"i3en.3xlarge": {
++		InstanceType: "i3en.3xlarge",
++		VCPU:         12,
++		MemoryMb:     98304,
++		GPU:          0,
++	},
++	"i3en.6xlarge": {
++		InstanceType: "i3en.6xlarge",
++		VCPU:         24,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"i3en.large": {
++		InstanceType: "i3en.large",
++		VCPU:         2,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"i3en.xlarge": {
++		InstanceType: "i3en.xlarge",
++		VCPU:         4,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"m1.large": {
++		InstanceType: "m1.large",
++		VCPU:         2,
++		MemoryMb:     7680,
++		GPU:          0,
++	},
++	"m1.medium": {
++		InstanceType: "m1.medium",
++		VCPU:         1,
++		MemoryMb:     3840,
++		GPU:          0,
++	},
++	"m1.small": {
++		InstanceType: "m1.small",
++		VCPU:         1,
++		MemoryMb:     1740,
++		GPU:          0,
++	},
++	"m1.xlarge": {
++		InstanceType: "m1.xlarge",
++		VCPU:         4,
++		MemoryMb:     15360,
++		GPU:          0,
++	},
++	"m2.2xlarge": {
++		InstanceType: "m2.2xlarge",
++		VCPU:         4,
++		MemoryMb:     35020,
++		GPU:          0,
++	},
++	"m2.4xlarge": {
++		InstanceType: "m2.4xlarge",
++		VCPU:         8,
++		MemoryMb:     70041,
++		GPU:          0,
++	},
++	"m2.xlarge": {
++		InstanceType: "m2.xlarge",
++		VCPU:         2,
++		MemoryMb:     17510,
++		GPU:          0,
++	},
++	"m3": {
++		InstanceType: "m3",
++		VCPU:         8,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"m3.2xlarge": {
++		InstanceType: "m3.2xlarge",
++		VCPU:         8,
++		MemoryMb:     30720,
++		GPU:          0,
++	},
++	"m3.large": {
++		InstanceType: "m3.large",
++		VCPU:         2,
++		MemoryMb:     7680,
++		GPU:          0,
++	},
++	"m3.medium": {
++		InstanceType: "m3.medium",
++		VCPU:         1,
++		MemoryMb:     3840,
++		GPU:          0,
++	},
++	"m3.xlarge": {
++		InstanceType: "m3.xlarge",
++		VCPU:         4,
++		MemoryMb:     15360,
++		GPU:          0,
++	},
++	"m4": {
++		InstanceType: "m4",
++		VCPU:         40,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"m4.10xlarge": {
++		InstanceType: "m4.10xlarge",
++		VCPU:         40,
++		MemoryMb:     163840,
++		GPU:          0,
++	},
++	"m4.16xlarge": {
++		InstanceType: "m4.16xlarge",
++		VCPU:         64,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"m4.2xlarge": {
++		InstanceType: "m4.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"m4.4xlarge": {
++		InstanceType: "m4.4xlarge",
++		VCPU:         16,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"m4.large": {
++		InstanceType: "m4.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"m4.xlarge": {
++		InstanceType: "m4.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"m5": {
++		InstanceType: "m5",
++		VCPU:         96,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"m5.12xlarge": {
++		InstanceType: "m5.12xlarge",
++		VCPU:         48,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"m5.16xlarge": {
++		InstanceType: "m5.16xlarge",
++		VCPU:         64,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"m5.24xlarge": {
++		InstanceType: "m5.24xlarge",
++		VCPU:         96,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"m5.2xlarge": {
++		InstanceType: "m5.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"m5.4xlarge": {
++		InstanceType: "m5.4xlarge",
++		VCPU:         16,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"m5.8xlarge": {
++		InstanceType: "m5.8xlarge",
++		VCPU:         32,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"m5.large": {
++		InstanceType: "m5.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"m5.metal": {
++		InstanceType: "m5.metal",
++		VCPU:         96,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"m5.xlarge": {
++		InstanceType: "m5.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"m5a.12xlarge": {
++		InstanceType: "m5a.12xlarge",
++		VCPU:         48,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"m5a.16xlarge": {
++		InstanceType: "m5a.16xlarge",
++		VCPU:         64,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"m5a.24xlarge": {
++		InstanceType: "m5a.24xlarge",
++		VCPU:         96,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"m5a.2xlarge": {
++		InstanceType: "m5a.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"m5a.4xlarge": {
++		InstanceType: "m5a.4xlarge",
++		VCPU:         16,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"m5a.8xlarge": {
++		InstanceType: "m5a.8xlarge",
++		VCPU:         32,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"m5a.large": {
++		InstanceType: "m5a.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"m5a.xlarge": {
++		InstanceType: "m5a.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"m5ad.12xlarge": {
++		InstanceType: "m5ad.12xlarge",
++		VCPU:         48,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"m5ad.24xlarge": {
++		InstanceType: "m5ad.24xlarge",
++		VCPU:         96,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"m5ad.2xlarge": {
++		InstanceType: "m5ad.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"m5ad.4xlarge": {
++		InstanceType: "m5ad.4xlarge",
++		VCPU:         16,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"m5ad.large": {
++		InstanceType: "m5ad.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"m5ad.xlarge": {
++		InstanceType: "m5ad.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"m5d": {
++		InstanceType: "m5d",
++		VCPU:         96,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"m5d.12xlarge": {
++		InstanceType: "m5d.12xlarge",
++		VCPU:         48,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"m5d.16xlarge": {
++		InstanceType: "m5d.16xlarge",
++		VCPU:         64,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"m5d.24xlarge": {
++		InstanceType: "m5d.24xlarge",
++		VCPU:         96,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"m5d.2xlarge": {
++		InstanceType: "m5d.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"m5d.4xlarge": {
++		InstanceType: "m5d.4xlarge",
++		VCPU:         16,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"m5d.8xlarge": {
++		InstanceType: "m5d.8xlarge",
++		VCPU:         32,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"m5d.large": {
++		InstanceType: "m5d.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"m5d.metal": {
++		InstanceType: "m5d.metal",
++		VCPU:         96,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"m5d.xlarge": {
++		InstanceType: "m5d.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"p2": {
++		InstanceType: "p2",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          16,
++		GPUMemory:    12000000000, // Rough estimate of 12 GB
++		MPSContext:   16,
++	},
++	"p2.16xlarge": {
++		InstanceType: "p2.16xlarge",
++		VCPU:         64,
++		MemoryMb:     786432,
++		GPU:          16,
++		GPUMemory:    192000000000,
++		MPSContext:   16,
++	},
++	"p2.8xlarge": {
++		InstanceType: "p2.8xlarge",
++		VCPU:         32,
++		MemoryMb:     499712,
++		GPU:          8,
++		GPUMemory:    96000000000,
++		MPSContext:   16,
++	},
++	"p2.xlarge": {
++		InstanceType: "p2.xlarge",
++		VCPU:         4,
++		MemoryMb:     62464,
++		GPU:          1,
++		GPUMemory:    12000000000,
++		MPSContext:   16,
++	},
++	"p3": {
++		InstanceType: "p3",
++		VCPU:         64,
++		MemoryMb:     499712,
++		GPU:          8,
++		GPUMemory:    16000000000,
++		MPSContext:   48,
++	},
++	"p3.16xlarge": {
++		InstanceType: "p3.16xlarge",
++		VCPU:         64,
++		MemoryMb:     499712,
++		GPU:          8,
++		GPUMemory:    128000000000,
++		MPSContext:   48,
++	},
++	"p3.2xlarge": {
++		InstanceType: "p3.2xlarge",
++		VCPU:         8,
++		MemoryMb:     62464,
++		GPU:          1,
++		GPUMemory:    16000000000,
++		MPSContext:   48,
++	},
++	"p3.8xlarge": {
++		InstanceType: "p3.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          4,
++		GPUMemory:    64000000000,
++		MPSContext:   48,
++	},
++	"r3": {
++		InstanceType: "r3",
++		VCPU:         32,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"r3.2xlarge": {
++		InstanceType: "r3.2xlarge",
++		VCPU:         8,
++		MemoryMb:     62464,
++		GPU:          0,
++	},
++	"r3.4xlarge": {
++		InstanceType: "r3.4xlarge",
++		VCPU:         16,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"r3.8xlarge": {
++		InstanceType: "r3.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"r3.large": {
++		InstanceType: "r3.large",
++		VCPU:         2,
++		MemoryMb:     15616,
++		GPU:          0,
++	},
++	"r3.xlarge": {
++		InstanceType: "r3.xlarge",
++		VCPU:         4,
++		MemoryMb:     31232,
++		GPU:          0,
++	},
++	"r4": {
++		InstanceType: "r4",
++		VCPU:         64,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"r4.16xlarge": {
++		InstanceType: "r4.16xlarge",
++		VCPU:         64,
++		MemoryMb:     499712,
++		GPU:          0,
++	},
++	"r4.2xlarge": {
++		InstanceType: "r4.2xlarge",
++		VCPU:         8,
++		MemoryMb:     62464,
++		GPU:          0,
++	},
++	"r4.4xlarge": {
++		InstanceType: "r4.4xlarge",
++		VCPU:         16,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"r4.8xlarge": {
++		InstanceType: "r4.8xlarge",
++		VCPU:         32,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"r4.large": {
++		InstanceType: "r4.large",
++		VCPU:         2,
++		MemoryMb:     15616,
++		GPU:          0,
++	},
++	"r4.xlarge": {
++		InstanceType: "r4.xlarge",
++		VCPU:         4,
++		MemoryMb:     31232,
++		GPU:          0,
++	},
++	"r5": {
++		InstanceType: "r5",
++		VCPU:         96,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"r5.12xlarge": {
++		InstanceType: "r5.12xlarge",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"r5.16xlarge": {
++		InstanceType: "r5.16xlarge",
++		VCPU:         64,
++		MemoryMb:     524288,
++		GPU:          0,
++	},
++	"r5.24xlarge": {
++		InstanceType: "r5.24xlarge",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"r5.2xlarge": {
++		InstanceType: "r5.2xlarge",
++		VCPU:         8,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"r5.4xlarge": {
++		InstanceType: "r5.4xlarge",
++		VCPU:         16,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"r5.8xlarge": {
++		InstanceType: "r5.8xlarge",
++		VCPU:         32,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"r5.large": {
++		InstanceType: "r5.large",
++		VCPU:         2,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"r5.metal": {
++		InstanceType: "r5.metal",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"r5.xlarge": {
++		InstanceType: "r5.xlarge",
++		VCPU:         4,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"r5a.12xlarge": {
++		InstanceType: "r5a.12xlarge",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"r5a.16xlarge": {
++		InstanceType: "r5a.16xlarge",
++		VCPU:         64,
++		MemoryMb:     524288,
++		GPU:          0,
++	},
++	"r5a.24xlarge": {
++		InstanceType: "r5a.24xlarge",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"r5a.2xlarge": {
++		InstanceType: "r5a.2xlarge",
++		VCPU:         8,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"r5a.4xlarge": {
++		InstanceType: "r5a.4xlarge",
++		VCPU:         16,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"r5a.8xlarge": {
++		InstanceType: "r5a.8xlarge",
++		VCPU:         32,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"r5a.large": {
++		InstanceType: "r5a.large",
++		VCPU:         2,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"r5a.xlarge": {
++		InstanceType: "r5a.xlarge",
++		VCPU:         4,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"r5ad.12xlarge": {
++		InstanceType: "r5ad.12xlarge",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"r5ad.24xlarge": {
++		InstanceType: "r5ad.24xlarge",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"r5ad.2xlarge": {
++		InstanceType: "r5ad.2xlarge",
++		VCPU:         8,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"r5ad.4xlarge": {
++		InstanceType: "r5ad.4xlarge",
++		VCPU:         16,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"r5ad.large": {
++		InstanceType: "r5ad.large",
++		VCPU:         2,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"r5ad.xlarge": {
++		InstanceType: "r5ad.xlarge",
++		VCPU:         4,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"r5d": {
++		InstanceType: "r5d",
++		VCPU:         96,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"r5d.12xlarge": {
++		InstanceType: "r5d.12xlarge",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"r5d.16xlarge": {
++		InstanceType: "r5d.16xlarge",
++		VCPU:         64,
++		MemoryMb:     524288,
++		GPU:          0,
++	},
++	"r5d.24xlarge": {
++		InstanceType: "r5d.24xlarge",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"r5d.2xlarge": {
++		InstanceType: "r5d.2xlarge",
++		VCPU:         8,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"r5d.4xlarge": {
++		InstanceType: "r5d.4xlarge",
++		VCPU:         16,
++		MemoryMb:     131072,
++		GPU:          0,
++	},
++	"r5d.8xlarge": {
++		InstanceType: "r5d.8xlarge",
++		VCPU:         32,
++		MemoryMb:     262144,
++		GPU:          0,
++	},
++	"r5d.large": {
++		InstanceType: "r5d.large",
++		VCPU:         2,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"r5d.metal": {
++		InstanceType: "r5d.metal",
++		VCPU:         96,
++		MemoryMb:     786432,
++		GPU:          0,
++	},
++	"r5d.xlarge": {
++		InstanceType: "r5d.xlarge",
++		VCPU:         4,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"t1.micro": {
++		InstanceType: "t1.micro",
++		VCPU:         1,
++		MemoryMb:     627,
++		GPU:          0,
++	},
++	"t2.2xlarge": {
++		InstanceType: "t2.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"t2.large": {
++		InstanceType: "t2.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"t2.medium": {
++		InstanceType: "t2.medium",
++		VCPU:         2,
++		MemoryMb:     4096,
++		GPU:          0,
++	},
++	"t2.micro": {
++		InstanceType: "t2.micro",
++		VCPU:         1,
++		MemoryMb:     1024,
++		GPU:          0,
++	},
++	"t2.nano": {
++		InstanceType: "t2.nano",
++		VCPU:         1,
++		MemoryMb:     512,
++		GPU:          0,
++	},
++	"t2.small": {
++		InstanceType: "t2.small",
++		VCPU:         1,
++		MemoryMb:     2048,
++		GPU:          0,
++	},
++	"t2.xlarge": {
++		InstanceType: "t2.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"t3.2xlarge": {
++		InstanceType: "t3.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"t3.large": {
++		InstanceType: "t3.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"t3.medium": {
++		InstanceType: "t3.medium",
++		VCPU:         2,
++		MemoryMb:     4096,
++		GPU:          0,
++	},
++	"t3.micro": {
++		InstanceType: "t3.micro",
++		VCPU:         2,
++		MemoryMb:     1024,
++		GPU:          0,
++	},
++	"t3.nano": {
++		InstanceType: "t3.nano",
++		VCPU:         2,
++		MemoryMb:     512,
++		GPU:          0,
++	},
++	"t3.small": {
++		InstanceType: "t3.small",
++		VCPU:         2,
++		MemoryMb:     2048,
++		GPU:          0,
++	},
++	"t3.xlarge": {
++		InstanceType: "t3.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"t3a.2xlarge": {
++		InstanceType: "t3a.2xlarge",
++		VCPU:         8,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++	"t3a.large": {
++		InstanceType: "t3a.large",
++		VCPU:         2,
++		MemoryMb:     8192,
++		GPU:          0,
++	},
++	"t3a.medium": {
++		InstanceType: "t3a.medium",
++		VCPU:         2,
++		MemoryMb:     4096,
++		GPU:          0,
++	},
++	"t3a.micro": {
++		InstanceType: "t3a.micro",
++		VCPU:         2,
++		MemoryMb:     1024,
++		GPU:          0,
++	},
++	"t3a.nano": {
++		InstanceType: "t3a.nano",
++		VCPU:         2,
++		MemoryMb:     512,
++		GPU:          0,
++	},
++	"t3a.small": {
++		InstanceType: "t3a.small",
++		VCPU:         2,
++		MemoryMb:     2048,
++		GPU:          0,
++	},
++	"t3a.xlarge": {
++		InstanceType: "t3a.xlarge",
++		VCPU:         4,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"u-12tb1": {
++		InstanceType: "u-12tb1",
++		VCPU:         448,
++		MemoryMb:     12582912,
++		GPU:          0,
++	},
++	"u-6tb1": {
++		InstanceType: "u-6tb1",
++		VCPU:         448,
++		MemoryMb:     6291456,
++		GPU:          0,
++	},
++	"u-9tb1": {
++		InstanceType: "u-9tb1",
++		VCPU:         448,
++		MemoryMb:     9437184,
++		GPU:          0,
++	},
++	"x1": {
++		InstanceType: "x1",
++		VCPU:         128,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"x1.16xlarge": {
++		InstanceType: "x1.16xlarge",
++		VCPU:         64,
++		MemoryMb:     999424,
++		GPU:          0,
++	},
++	"x1.32xlarge": {
++		InstanceType: "x1.32xlarge",
++		VCPU:         128,
++		MemoryMb:     1998848,
++		GPU:          0,
++	},
++	"x1e": {
++		InstanceType: "x1e",
++		VCPU:         128,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"x1e.16xlarge": {
++		InstanceType: "x1e.16xlarge",
++		VCPU:         64,
++		MemoryMb:     1998848,
++		GPU:          0,
++	},
++	"x1e.2xlarge": {
++		InstanceType: "x1e.2xlarge",
++		VCPU:         8,
++		MemoryMb:     249856,
++		GPU:          0,
++	},
++	"x1e.32xlarge": {
++		InstanceType: "x1e.32xlarge",
++		VCPU:         128,
++		MemoryMb:     3997696,
++		GPU:          0,
++	},
++	"x1e.4xlarge": {
++		InstanceType: "x1e.4xlarge",
++		VCPU:         16,
++		MemoryMb:     499712,
++		GPU:          0,
++	},
++	"x1e.8xlarge": {
++		InstanceType: "x1e.8xlarge",
++		VCPU:         32,
++		MemoryMb:     999424,
++		GPU:          0,
++	},
++	"x1e.xlarge": {
++		InstanceType: "x1e.xlarge",
++		VCPU:         4,
++		MemoryMb:     124928,
++		GPU:          0,
++	},
++	"z1d": {
++		InstanceType: "z1d",
++		VCPU:         48,
++		MemoryMb:     0,
++		GPU:          0,
++	},
++	"z1d.12xlarge": {
++		InstanceType: "z1d.12xlarge",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"z1d.2xlarge": {
++		InstanceType: "z1d.2xlarge",
++		VCPU:         8,
++		MemoryMb:     65536,
++		GPU:          0,
++	},
++	"z1d.3xlarge": {
++		InstanceType: "z1d.3xlarge",
++		VCPU:         12,
++		MemoryMb:     98304,
++		GPU:          0,
++	},
++	"z1d.6xlarge": {
++		InstanceType: "z1d.6xlarge",
++		VCPU:         24,
++		MemoryMb:     196608,
++		GPU:          0,
++	},
++	"z1d.large": {
++		InstanceType: "z1d.large",
++		VCPU:         2,
++		MemoryMb:     16384,
++		GPU:          0,
++	},
++	"z1d.metal": {
++		InstanceType: "z1d.metal",
++		VCPU:         48,
++		MemoryMb:     393216,
++		GPU:          0,
++	},
++	"z1d.xlarge": {
++		InstanceType: "z1d.xlarge",
++		VCPU:         4,
++		MemoryMb:     32768,
++		GPU:          0,
++	},
++}
+diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go
+new file mode 100644
+index 000000000..7644f921d
+--- /dev/null
++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go
+@@ -0,0 +1,152 @@
++/*
++Copyright 2016 The Kubernetes Authors.
++Licensed under the Apache License, Version 2.0 (the "License");
++you may not use this file except in compliance with the License.
++You may obtain a copy of the License at
++    http://www.apache.org/licenses/LICENSE-2.0
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an "AS IS" BASIS,
++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++*/
++
++package spotinst
++
++import (
++	"io"
++	apiv1 "k8s.io/api/core/v1"
++	"k8s.io/apimachinery/pkg/api/resource"
++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
++	"k8s.io/autoscaler/cluster-autoscaler/config"
++	"k8s.io/autoscaler/cluster-autoscaler/utils/errors"
++	"k8s.io/klog"
++	"os"
++)
++
++const (
++	ProviderName = "spotinst"
++
++	// GPULabel is the label added to nodes with GPU resource.
++	GPULabel = "k8s.amazonaws.com/accelerator"
++)
++
++// CloudProvider implements CloudProvider interface.
++type CloudProvider struct {
++	manager         *CloudManager
++	resourceLimiter *cloudprovider.ResourceLimiter
++}
++
++var (
++	availableGPUTypes = map[string]struct{}{
++		"nvidia-tesla-k80":  {},
++		"nvidia-tesla-p100": {},
++		"nvidia-tesla-v100": {},
++	}
++)
++
++// NewCloudProvider returns CloudProvider implementation for Spotinst.
++func NewCloudProvider(manager *CloudManager, resourceLimiter *cloudprovider.ResourceLimiter) (*CloudProvider, error) {
++	klog.Info("Building Spotinst cloud provider")
++	cloud := &CloudProvider{
++		manager:         manager,
++		resourceLimiter: resourceLimiter,
++	}
++
++	return cloud, nil
++}
++
++// Name returns name of the cloud c.
++func (c *CloudProvider) Name() string {
++	return ProviderName
++}
++
++// NodeGroups returns all node groups configured for this cloud c.
++func (c *CloudProvider) NodeGroups() []cloudprovider.NodeGroup {
++	out := make([]cloudprovider.NodeGroup, len(c.manager.groups))
++	for i, group := range c.manager.groups {
++		out[i] = group
++	}
++	return out
++}
++
++// NodeGroupForNode returns the node group for the given node.
++func (c *CloudProvider) NodeGroupForNode(node *apiv1.Node) (cloudprovider.NodeGroup, error) {
++	instanceID, err := extractInstanceId(node.Spec.ProviderID)
++	if err != nil {
++		return nil, err
++	}
++	return c.manager.GetGroupForInstance(instanceID)
++}
++
++// Pricing returns pricing model for this cloud provider or error if not available.
++func (c *CloudProvider) Pricing() (cloudprovider.PricingModel, errors.AutoscalerError) {
++	return nil, cloudprovider.ErrNotImplemented
++}
++
++// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.
++// Implementation optional.
++func (c *CloudProvider) GetAvailableMachineTypes() ([]string, error) {
++	return []string{}, nil
++}
++
++// NewNodeGroup builds a theoretical node group based on the node definition provided.
++func (c *CloudProvider) NewNodeGroup(machineType string, labels map[string]string, systemLabels map[string]string,
++	taints []apiv1.Taint, extraResources map[string]resource.Quantity) (cloudprovider.NodeGroup, error) {
++	return nil, cloudprovider.ErrNotImplemented
++}
++
++// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).
++func (c *CloudProvider) GetResourceLimiter() (*cloudprovider.ResourceLimiter, error) {
++	return c.resourceLimiter, nil
++}
++
++// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.
++func (c *CloudProvider) Cleanup() error {
++	return c.manager.Cleanup()
++}
++
++// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
++// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
++func (c *CloudProvider) Refresh() error {
++	return c.manager.Refresh()
++}
++
++// GetInstanceID gets the instance ID for the specified node.
++func (c *CloudProvider) GetInstanceID(node *apiv1.Node) string {
++	return node.Spec.ProviderID
++}
++
++// GPULabel returns the label added to nodes with GPU resource.
++func (c *CloudProvider) GPULabel() string {
++	return GPULabel
++}
++
++// GetAvailableGPUTypes return all available GPU types cloud provider supports
++func (c *CloudProvider) GetAvailableGPUTypes() map[string]struct{} {
++	return availableGPUTypes
++}
++
++func BuildSpotinst(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
++	var config io.ReadCloser
++	if opts.CloudConfig != "" {
++		var err error
++		config, err = os.Open(opts.CloudConfig)
++		if err != nil {
++			klog.Fatalf("Couldn't open cloud provider configuration %s: %#v", opts.CloudConfig, err)
++		}
++		defer config.Close()
++	}
++
++	manager, err := NewCloudManager(config, do)
++	if err != nil {
++		klog.Fatalf("Failed to create Spotinst manager: %v", err)
++	}
++
++	provider, err := NewCloudProvider(manager, rl)
++	if err != nil {
++		klog.Fatalf("Failed to create Spotinst cloud provider: %v", err)
++	}
++
++	return provider
++}
+diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go
+new file mode 100644
+index 000000000..28ee79069
+--- /dev/null
++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go
+@@ -0,0 +1,409 @@
++/*
++Copyright 2016 The Kubernetes Authors.
++Licensed under the Apache License, Version 2.0 (the "License");
++you may not use this file except in compliance with the License.
++You may obtain a copy of the License at
++    http://www.apache.org/licenses/LICENSE-2.0
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an "AS IS" BASIS,
++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++*/
++
++package spotinst
++
++import (
++	"context"
++	"testing"
++	"time"
++
++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/azure"
++	azurev3 "github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/azure/v3"
++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/gcp"
++	"github.com/spotinst/spotinst-sdk-go/spotinst"
++	"github.com/stretchr/testify/assert"
++	"github.com/stretchr/testify/mock"
++	apiv1 "k8s.io/api/core/v1"
++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
++)
++
++type groupServiceMock struct {
++	mock.Mock
++	providerAWS *awsServiceMock
++}
++
++func (s *groupServiceMock) CloudProviderAWS() aws.Service {
++	return s.providerAWS
++}
++
++func (s *groupServiceMock) CloudProviderGCP() gcp.Service {
++	return nil // not implemented
++}
++
++func (s *groupServiceMock) CloudProviderAzure() azure.Service {
++	return nil // not implemented
++}
++
++func (s *groupServiceMock) CloudProviderAzureV3() azurev3.Service {
++	return nil // not implemented
++}
++
++type awsServiceMock struct {
++	mock.Mock
++}
++
++func (s *awsServiceMock) List(ctx context.Context, input *aws.ListGroupsInput) (*aws.ListGroupsOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) Create(ctx context.Context, input *aws.CreateGroupInput) (*aws.CreateGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) DeploymentStatusECS(context.Context, *aws.DeploymentStatusInput) (*aws.RollGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) DeploymentStatus(context.Context, *aws.DeploymentStatusInput) (*aws.RollGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) RollECS(context.Context, *aws.RollECSGroupInput) (*aws.RollGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) Scale(context.Context, *aws.ScaleGroupInput) (*aws.ScaleGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) FinishBeanstalkMaintenance(context.Context, *aws.BeanstalkMaintenanceInput) (*aws.BeanstalkMaintenanceOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) GetBeanstalkMaintenanceStatus(context.Context, *aws.BeanstalkMaintenanceInput) (*string, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) GetGroupEvents(context.Context, *aws.GetGroupEventsInput) (*aws.GetGroupEventsOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) StartBeanstalkMaintenance(context.Context, *aws.BeanstalkMaintenanceInput) (*aws.BeanstalkMaintenanceOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) Read(ctx context.Context, input *aws.ReadGroupInput) (*aws.ReadGroupOutput, error) {
++	out := &aws.ReadGroupOutput{
++		Group: &aws.Group{
++			Capacity: &aws.Capacity{
++				Target: spotinst.Int(2),
++			},
++		},
++	}
++	return out, nil
++}
++
++func (s *awsServiceMock) GetInstanceHealthiness(context.Context, *aws.GetInstanceHealthinessInput) (*aws.GetInstanceHealthinessOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) ImportBeanstalkEnv(context.Context, *aws.ImportBeanstalkInput) (*aws.ImportBeanstalkOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) StopDeployment(context.Context, *aws.StopDeploymentInput) (*aws.StopDeploymentOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) Update(ctx context.Context, input *aws.UpdateGroupInput) (*aws.UpdateGroupOutput, error) {
++	args := s.Called(ctx, input)
++	return args.Get(0).(*aws.UpdateGroupOutput), nil
++}
++
++func (s *awsServiceMock) Delete(ctx context.Context, input *aws.DeleteGroupInput) (*aws.DeleteGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) Status(ctx context.Context, input *aws.StatusGroupInput) (*aws.StatusGroupOutput, error) {
++	out := &aws.StatusGroupOutput{
++		Instances: []*aws.Instance{
++			{
++				ID: spotinst.String("test-instance-id"),
++			},
++			{
++				ID: spotinst.String("second-test-instance-id"),
++			},
++		},
++	}
++	return out, nil
++}
++
++func (s *awsServiceMock) Detach(ctx context.Context, input *aws.DetachGroupInput) (*aws.DetachGroupOutput, error) {
++	args := s.Called(ctx, input)
++	return args.Get(0).(*aws.DetachGroupOutput), nil
++}
++
++func (s *awsServiceMock) Roll(ctx context.Context, input *aws.RollGroupInput) (*aws.RollGroupOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) CreateSuspensions(ctx context.Context, input *aws.CreateSuspensionsInput) (*aws.CreateSuspensionsOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) ListSuspensions(context.Context, *aws.ListSuspensionsInput) (*aws.ListSuspensionsOutput, error) {
++	return nil, nil
++}
++func (s *awsServiceMock) DeleteSuspensions(context.Context, *aws.DeleteSuspensionsInput) (*aws.DeleteSuspensionsOutput, error) {
++	return nil, nil
++}
++
++func (s *awsServiceMock) ListStatefulInstances(context.Context, *aws.ListStatefulInstancesInput) (*aws.ListStatefulInstancesOutput, error) {
++	return nil, nil
++}
++func (s *awsServiceMock) PauseStatefulInstance(context.Context, *aws.PauseStatefulInstanceInput) (*aws.PauseStatefulInstanceOutput, error) {
++	return nil, nil
++}
++func (s *awsServiceMock) ResumeStatefulInstance(context.Context, *aws.ResumeStatefulInstanceInput) (*aws.ResumeStatefulInstanceOutput, error) {
++	return nil, nil
++}
++func (s *awsServiceMock) RecycleStatefulInstance(context.Context, *aws.RecycleStatefulInstanceInput) (*aws.RecycleStatefulInstanceOutput, error) {
++	return nil, nil
++}
++func (s *awsServiceMock) DeallocateStatefulInstance(context.Context, *aws.DeallocateStatefulInstanceInput) (*aws.DeallocateStatefulInstanceOutput, error) {
++	return nil, nil
++}
++
++func testCloudManager(t *testing.T) *CloudManager {
++	return &CloudManager{
++		groupService: &groupServiceMock{
++			providerAWS: new(awsServiceMock),
++		},
++		groups:          make([]*Group, 0),
++		cache:           make(map[string]*Group),
++		interruptCh:     make(chan struct{}),
++		refreshInterval: time.Minute,
++	}
++}
++
++func testCloudProvider(t *testing.T, m *CloudManager) *CloudProvider {
++	resourceLimiter := cloudprovider.NewResourceLimiter(
++		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
++		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
++
++	cloud, err := NewCloudProvider(m, resourceLimiter)
++	assert.NoError(t, err)
++	return cloud
++}
++
++func TestNewCloudProvider(t *testing.T) {
++	testCloudProvider(t, testCloudManager(t))
++}
++
++func TestAddNodeGroup(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("bad spec")
++	assert.Error(t, err)
++	assert.Equal(t, len(provider.manager.groups), 0)
++
++	err = provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.manager.groups), 1)
++}
++
++func TestName(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	assert.Equal(t, provider.Name(), "spotinst")
++}
++
++func TestNodeGroups(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	assert.Equal(t, len(provider.NodeGroups()), 0)
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.NodeGroups()), 1)
++}
++
++func TestNodeGroupForNode(t *testing.T) {
++	node := &apiv1.Node{
++		Spec: apiv1.NodeSpec{
++			ProviderID: "aws:///us-east-1a/test-instance-id",
++		},
++	}
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	group, err := provider.NodeGroupForNode(node)
++
++	assert.NoError(t, err)
++	assert.Equal(t, group.Id(), "sig-test")
++	assert.Equal(t, group.MinSize(), 1)
++	assert.Equal(t, group.MaxSize(), 5)
++
++	// test node in cluster that is not in a group managed by cluster autoscaler
++	nodeNotInGroup := &apiv1.Node{
++		Spec: apiv1.NodeSpec{
++			ProviderID: "aws:///us-east-1a/test-instance-id-not-in-group",
++		},
++	}
++
++	group, err = provider.NodeGroupForNode(nodeNotInGroup)
++	assert.NoError(t, err)
++	assert.Nil(t, group)
++}
++
++func TestExtractInstanceId(t *testing.T) {
++	_, err := extractInstanceId("bad spec")
++	assert.Error(t, err)
++
++	instanceID, err := extractInstanceId("aws:///us-east-1a/i-260942b3")
++	assert.NoError(t, err)
++	assert.Equal(t, instanceID, "i-260942b3")
++}
++
++func TestMaxSize(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.manager.groups), 1)
++	assert.Equal(t, provider.manager.groups[0].MaxSize(), 5)
++}
++
++func TestMinSize(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.manager.groups), 1)
++	assert.Equal(t, provider.manager.groups[0].MinSize(), 1)
++}
++
++func TestTargetSize(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	targetSize, err := provider.manager.groups[0].TargetSize()
++	assert.Equal(t, targetSize, 2)
++	assert.NoError(t, err)
++}
++
++func TestIncreaseSize(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.manager.groups), 1)
++
++	cloud := provider.manager.groupService.CloudProviderAWS().(*awsServiceMock)
++	cloud.On("Update", context.Background(), &aws.UpdateGroupInput{
++		Group: &aws.Group{
++			ID: spotinst.String(provider.manager.groups[0].Id()),
++			Capacity: &aws.Capacity{
++				Target:  spotinst.Int(3),
++				Minimum: spotinst.Int(provider.manager.groups[0].minSize),
++				Maximum: spotinst.Int(provider.manager.groups[0].maxSize),
++			},
++		},
++	}).Return(&aws.UpdateGroupOutput{})
++
++	err = provider.manager.groups[0].IncreaseSize(1)
++	assert.NoError(t, err)
++	cloud.AssertExpectations(t)
++}
++
++func TestBelongs(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++
++	invalidNode := &apiv1.Node{
++		Spec: apiv1.NodeSpec{
++			ProviderID: "aws:///us-east-1a/invalid-instance-id",
++		},
++	}
++	_, err = provider.manager.groups[0].Belongs(invalidNode)
++	assert.Error(t, err)
++
++	validNode := &apiv1.Node{
++		Spec: apiv1.NodeSpec{
++			ProviderID: "aws:///us-east-1a/test-instance-id",
++		},
++	}
++	belongs, err := provider.manager.groups[0].Belongs(validNode)
++	assert.Equal(t, belongs, true)
++	assert.NoError(t, err)
++}
++
++func TestDeleteNodes(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.manager.groups), 1)
++
++	cloud := provider.manager.groupService.CloudProviderAWS().(*awsServiceMock)
++	cloud.On("Detach", context.Background(), &aws.DetachGroupInput{
++		GroupID:                       spotinst.String(provider.manager.groups[0].Id()),
++		InstanceIDs:                   []string{"test-instance-id"},
++		ShouldDecrementTargetCapacity: spotinst.Bool(true),
++		ShouldTerminateInstances:      spotinst.Bool(true),
++	}).Return(&aws.DetachGroupOutput{})
++
++	node := &apiv1.Node{
++		Spec: apiv1.NodeSpec{
++			ProviderID: "aws:///us-east-1a/test-instance-id",
++		},
++	}
++
++	err = provider.manager.groups[0].DeleteNodes([]*apiv1.Node{node})
++	assert.NoError(t, err)
++	cloud.AssertExpectations(t)
++}
++
++func TestId(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.manager.addNodeGroup("1:5:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, len(provider.manager.groups), 1)
++	assert.Equal(t, provider.manager.groups[0].Id(), "sig-test")
++}
++
++func TestDebug(t *testing.T) {
++	grp := Group{
++		manager: testCloudManager(t),
++		minSize: 5,
++		maxSize: 55,
++	}
++	grp.groupID = "sig-test"
++	assert.Equal(t, grp.Debug(), "sig-test (5:55)")
++}
++
++func TestBuildGroup(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++
++	_, err := provider.manager.buildGroupFromSpec("a")
++	assert.Error(t, err)
++	_, err = provider.manager.buildGroupFromSpec("a:b:c")
++	assert.Error(t, err)
++	_, err = provider.manager.buildGroupFromSpec("1:")
++	assert.Error(t, err)
++	_, err = provider.manager.buildGroupFromSpec("1:2:")
++	assert.Error(t, err)
++
++	grp, err := provider.manager.buildGroupFromSpec("111:222:sig-test")
++	assert.NoError(t, err)
++	assert.Equal(t, 111, grp.MinSize())
++	assert.Equal(t, 222, grp.MaxSize())
++	assert.Equal(t, "sig-test", grp.Id())
++}
++
++func TestGetResourceLimiter(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	_, err := provider.GetResourceLimiter()
++	assert.NoError(t, err)
++}
++
++func TestCleanup(t *testing.T) {
++	provider := testCloudProvider(t, testCloudManager(t))
++	err := provider.Cleanup()
++	assert.NoError(t, err)
++}
+diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go
+new file mode 100644
+index 000000000..9f1ed24e9
+--- /dev/null
++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go
+@@ -0,0 +1,510 @@
++/*
++Copyright 2016 The Kubernetes Authors.
++Licensed under the Apache License, Version 2.0 (the "License");
++you may not use this file except in compliance with the License.
++You may obtain a copy of the License at
++    http://www.apache.org/licenses/LICENSE-2.0
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an "AS IS" BASIS,
++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++*/
++
++package spotinst
++
++import (
++	"context"
++	"errors"
++	"fmt"
++	"io"
++	"k8s.io/autoscaler/cluster-autoscaler/utils/gpu"
++	"k8s.io/klog"
++	"math/rand"
++	"strconv"
++	"strings"
++	"sync"
++	"time"
++
++	"k8s.io/autoscaler/cluster-autoscaler/utils/mpscontext"
++
++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup"
++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
++	"github.com/spotinst/spotinst-sdk-go/spotinst"
++	"github.com/spotinst/spotinst-sdk-go/spotinst/log"
++	"github.com/spotinst/spotinst-sdk-go/spotinst/session"
++	"github.com/spotinst/spotinst-sdk-go/spotinst/util/stringutil"
++	apiv1 "k8s.io/api/core/v1"
++	"k8s.io/apimachinery/pkg/api/resource"
++	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
++	"k8s.io/apimachinery/pkg/util/wait"
++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
++	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
++	"k8s.io/autoscaler/cluster-autoscaler/utils/gpumemory"
++	kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
++	gcfg "gopkg.in/gcfg.v1"
++)
++
++// CloudManager holds the config and client.
++type CloudManager struct {
++	groupService    elastigroup.Service
++	groups          []*Group
++	refreshedAt     time.Time
++	refreshInterval time.Duration
++	interruptCh     chan struct{}
++	cacheMu         sync.Mutex
++	cache           map[string]*Group // k: InstanceID, v: Group
++}
++
++// CloudConfig holds the configuration parsed from the --cloud-config flag.
++// All fields are required unless otherwise specified.
++type CloudConfig struct {
++	Global struct{}
++}
++
++// NewCloudManager constructs manager object.
++func NewCloudManager(config io.Reader, discoveryOpts cloudprovider.NodeGroupDiscoveryOptions) (*CloudManager, error) {
++	klog.Info("Building Spotinst cloud manager")
++
++	cfg, err := readCloudConfig(config)
++	if err != nil {
++		return nil, err
++	}
++
++	svc, err := newService(cfg)
++	if err != nil {
++		return nil, err
++	}
++
++	manager := &CloudManager{
++		groupService:    svc,
++		refreshInterval: time.Minute,
++		interruptCh:     make(chan struct{}),
++		groups:          make([]*Group, 0),
++		cache:           make(map[string]*Group),
++	}
++
++	if err := manager.addNodeGroups(discoveryOpts.NodeGroupSpecs); err != nil {
++		return nil, err
++	}
++
++	go wait.Until(func() {
++		manager.cacheMu.Lock()
++		defer manager.cacheMu.Unlock()
++
++		if err := manager.forceRefresh(); err != nil {
++			klog.Errorf("Error while refreshing cache: %v", err)
++		}
++	}, time.Hour, manager.interruptCh)
++
++	return manager, nil
++}
++
++// newService returns a new instance of Spotinst Service.
++func newService(cloudConfig *CloudConfig) (elastigroup.Service, error) {
++	// Create a new config.
++	config := spotinst.DefaultConfig()
++	config.WithLogger(newStdLogger())
++	config.WithUserAgent("Kubernetes-ClusterAutoscaler")
++
++	// Create a new session.
++	sess := session.New(config)
++
++	// Create a new service.
++	svc := elastigroup.New(sess)
++
++	return svc, nil
++}
++
++func newStdLogger() log.Logger {
++	return log.LoggerFunc(func(format string, args ...interface{}) {
++		klog.V(4).Infof(format, args...)
++	})
++}
++
++// readCloudConfig reads an instance of Config from config reader.
++func readCloudConfig(config io.Reader) (*CloudConfig, error) {
++	var cfg CloudConfig
++
++	if config != nil {
++		if err := gcfg.ReadInto(&cfg, config); err != nil {
++			return nil, fmt.Errorf("couldn't read Spotinst config: %v", err)
++		}
++	}
++
++	return &cfg, nil
++}
++
++func (mgr *CloudManager) addNodeGroups(specs []string) error {
++	klog.Info("Attempting to add node groups")
++
++	for _, spec := range specs {
++		if err := mgr.addNodeGroup(spec); err != nil {
++			return fmt.Errorf("could not register group with spec %s: %v", spec, err)
++		}
++	}
++
++	return nil
++}
++
++func (mgr *CloudManager) addNodeGroup(spec string) error {
++	klog.Infof("Attempting to add node group: %s", spec)
++
++	group, err := mgr.buildGroupFromSpec(spec)
++	if err != nil {
++		return fmt.Errorf("could not parse spec for node group: %v", err)
++	}
++	err = mgr.RegisterGroup(group)
++	if err != nil {
++		return fmt.Errorf("could not register the group(%s): %v", group.Id(), err)
++	}
++
++	klog.Infof("Node group added: %s", group.groupID)
++	return nil
++}
++
++func (mgr *CloudManager) buildGroupFromSpec(value string) (*Group, error) {
++	spec, err := dynamic.SpecFromString(value, true)
++	if err != nil {
++		return nil, fmt.Errorf("failed to parse node group spec: %v", err)
++	}
++	group := &Group{
++		manager: mgr,
++		groupID: spec.Name,
++		minSize: spec.MinSize,
++		maxSize: spec.MaxSize,
++	}
++	return group, nil
++}
++
++// RegisterGroup registers a resource group in Spotinst Manager.
++func (mgr *CloudManager) RegisterGroup(grp *Group) error {
++	mgr.cacheMu.Lock()
++	defer mgr.cacheMu.Unlock()
++
++	group, err := mgr.getResourceForGroup(grp.Id())
++	if err != nil {
++		return err
++	}
++	grp.group = group
++
++	mgr.groups = append(mgr.groups, grp)
++	return nil
++}
++
++// GetGroupSize gets the current size of the group.
++func (mgr *CloudManager) GetGroupSize(grp *Group) (int64, error) {
++	group, err := mgr.getResourceForGroup(grp.Id())
++	if err != nil {
++		return -1, err
++	}
++	size := spotinst.IntValue(group.Capacity.Target)
++	return int64(size), nil
++}
++
++// SetGroupSize sets the instances count in a Group by updating a
++// predefined Spotinst stack parameter (specified by the user).
++func (mgr *CloudManager) SetGroupSize(grp *Group, size int64) error {
++	in := &aws.UpdateGroupInput{
++		Group: &aws.Group{
++			ID: spotinst.String(grp.Id()),
++			Capacity: &aws.Capacity{
++				Target:  spotinst.Int(int(size)),
++				Minimum: spotinst.Int(grp.minSize),
++				Maximum: spotinst.Int(grp.maxSize),
++			},
++		},
++	}
++	_, err := mgr.groupService.CloudProviderAWS().Update(context.Background(), in)
++	if err != nil {
++		return err
++	}
++	return nil
++}
++
++// GetGroupForInstance retrieves the resource group that contains
++// a given instance.
++func (mgr *CloudManager) GetGroupForInstance(instanceID string) (*Group, error) {
++	mgr.cacheMu.Lock()
++	defer mgr.cacheMu.Unlock()
++
++	if group, ok := mgr.cache[instanceID]; ok {
++		return group, nil
++	}
++
++	if err := mgr.forceRefresh(); err != nil {
++		return nil, err
++	}
++
++	if group, ok := mgr.cache[instanceID]; ok {
++		return group, nil
++	}
++
++	klog.Warningf("Instance `%s` does not belong to any managed group", instanceID)
++	return nil, nil
++}
++
++// DeleteInstances deletes the specified instances from the
++// OpenStack resource group
++func (mgr *CloudManager) DeleteInstances(instanceIDs []string) error {
++	if len(instanceIDs) == 0 {
++		return nil
++	}
++	commonGroup, err := mgr.GetGroupForInstance(instanceIDs[0])
++	if err != nil {
++		return err
++	}
++	for _, instanceID := range instanceIDs {
++		instanceGroup, err := mgr.GetGroupForInstance(instanceID)
++		if err != nil {
++			return err
++		}
++		if instanceGroup.groupID != commonGroup.groupID {
++			return errors.New("connot delete instances which don't belong to the same group")
++		}
++	}
++	in := &aws.DetachGroupInput{
++		GroupID:                       spotinst.String(commonGroup.groupID),
++		InstanceIDs:                   instanceIDs,
++		ShouldDecrementTargetCapacity: spotinst.Bool(true),
++		ShouldTerminateInstances:      spotinst.Bool(true),
++	}
++	if _, err := mgr.groupService.CloudProviderAWS().Detach(context.Background(), in); err != nil {
++		return fmt.Errorf("failed to detach instances from group %s: %v", commonGroup.groupID, err)
++	}
++	return nil
++}
++
++func (mgr *CloudManager) getResourceForGroup(groupID string) (*aws.Group, error) {
++	in := &aws.ReadGroupInput{
++		GroupID: spotinst.String(groupID),
++	}
++	out, err := mgr.groupService.CloudProviderAWS().Read(context.Background(), in)
++	if err != nil {
++		return nil, err
++	}
++	if out.Group == nil {
++		return nil, fmt.Errorf("failed to get group %s", groupID)
++	}
++	return out.Group, nil
++}
++
++// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.
++func (mgr *CloudManager) Cleanup() error {
++	close(mgr.interruptCh)
++	return nil
++}
++
++// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
++// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
++func (mgr *CloudManager) Refresh() error {
++	mgr.cacheMu.Lock()
++	defer mgr.cacheMu.Unlock()
++
++	if mgr.refreshedAt.Add(mgr.refreshInterval).After(time.Now()) {
++		return nil
++	}
++	return mgr.forceRefresh()
++}
++
++func (mgr *CloudManager) forceRefresh() error {
++	mgr.regenerateCache()
++	mgr.refreshedAt = time.Now()
++	klog.V(2).Infof("Refreshed, next refresh after %v", mgr.refreshedAt.Add(mgr.refreshInterval))
++	return nil
++}
++
++func (mgr *CloudManager) regenerateCache() {
++	mgr.cache = make(map[string]*Group)
++	for _, group := range mgr.groups {
++		klog.V(4).Infof("Regenerating resource group information for %s", group.groupID)
++		if err := mgr.refreshGroupNodes(group); err != nil {
++			klog.Warningf("Could not retrieve nodes for group %s: %v", group.groupID, err)
++		}
++	}
++}
++
++func (mgr *CloudManager) refreshGroupNodes(grp *Group) error {
++	in := &aws.StatusGroupInput{
++		GroupID: spotinst.String(grp.Id()),
++	}
++	status, err := mgr.groupService.CloudProviderAWS().Status(context.Background(), in)
++	if err != nil {
++		return err
++	}
++	for _, instance := range status.Instances {
++		if instance.ID != nil {
++			instanceID := spotinst.StringValue(instance.ID)
++			klog.Infof("Managing AWS instance with ID %s in group %s", instanceID, grp.Id())
++			mgr.cache[instanceID] = grp
++		}
++	}
++	return nil
++}
++
++type groupTemplate struct {
++	InstanceType *instanceType
++	Region       string
++	Zone         string
++	Tags         []*aws.Tag
++}
++
++func (mgr *CloudManager) inferInstanceType(instanceTypeName string) *instanceType {
++	ret := &instanceType{
++		InstanceType: instanceTypeName,
++		VCPU:         1,
++		MemoryMb:     1024, // 1GB
++		GPU:          0,
++	}
++	size := 1
++	if strings.HasSuffix(instanceTypeName, ".medium") || strings.HasSuffix(instanceTypeName, ".large") {
++		size = 1
++	} else if strings.HasSuffix(instanceTypeName, ".xlarge") {
++		size = 2
++	} else {
++		elems := strings.Split(instanceTypeName, ".")
++		if len(elems) > 1 {
++			nums := strings.Split(elems[1], "xlarge")
++			if len(nums) > 0 {
++				if num, err := strconv.Atoi(nums[0]); err == nil {
++					size = num * 2
++				}
++			}
++		}
++	}
++	ret.VCPU = 2 * int64(size)
++	ret.MemoryMb = 1024 * 2 * ret.VCPU
++	if strings.HasPrefix(instanceTypeName, "g") || strings.HasPrefix(instanceTypeName, "p") {
++		ret.GPU = int64(size / 4)
++		if ret.GPU <= 0 {
++			ret.GPU = 1
++		}
++	}
++	return ret
++}
++
++func (mgr *CloudManager) buildGroupTemplate(groupID string) (*groupTemplate, error) {
++	klog.Infof("Building template for group %s", groupID)
++
++	group, err := mgr.getResourceForGroup(groupID)
++	if err != nil {
++		return nil, err
++	}
++
++	if len(group.Compute.AvailabilityZones) < 1 {
++		return nil, fmt.Errorf("unable to get first AvailabilityZone for %s", groupID)
++	}
++
++	zone := spotinst.StringValue(group.Compute.AvailabilityZones[0].Name)
++	region := zone[0 : len(zone)-1]
++
++	if len(group.Compute.AvailabilityZones) > 1 {
++		klog.Warningf("Found multiple availability zones, using %s", zone)
++	}
++
++	instanceTypeName := spotinst.StringValue(group.Compute.InstanceTypes.OnDemand)
++	foundInstanceType := InstanceTypes[instanceTypeName]
++	if foundInstanceType == nil {
++		klog.Warningf("Unable to get node template info for instance type %s", instanceTypeName)
++		foundInstanceType = mgr.inferInstanceType(instanceTypeName)
++	}
++
++	tmpl := &groupTemplate{
++		InstanceType: foundInstanceType,
++		Region:       region,
++		Zone:         zone,
++		Tags:         group.Compute.LaunchSpecification.Tags,
++	}
++
++	return tmpl, nil
++}
++
++func (mgr *CloudManager) buildNodeFromTemplate(group *Group, template *groupTemplate) (*apiv1.Node, error) {
++	klog.Infof("Building node from template of group %s", group.Id())
++
++	node := apiv1.Node{}
++	nodeName := fmt.Sprintf("%s-group-%d", group.groupID, rand.Int63())
++
++	node.ObjectMeta = metav1.ObjectMeta{
++		Name:     nodeName,
++		SelfLink: fmt.Sprintf("/api/v1/nodes/%s", nodeName),
++		Labels:   map[string]string{},
++	}
++
++	node.Status = apiv1.NodeStatus{
++		Capacity: apiv1.ResourceList{},
++	}
++
++	node.Status.Capacity[apiv1.ResourcePods] = *resource.NewQuantity(110, resource.DecimalSI)
++	node.Status.Capacity[apiv1.ResourceCPU] = *resource.NewQuantity(template.InstanceType.VCPU, resource.DecimalSI)
++	node.Status.Capacity[apiv1.ResourceMemory] = *resource.NewQuantity(template.InstanceType.MemoryMb*1024*1024, resource.DecimalSI)
++	node.Status.Capacity[gpu.ResourceNvidiaGPU] = *resource.NewQuantity(template.InstanceType.GPU, resource.DecimalSI)
++	node.Status.Capacity[gpumemory.ResourceVisenzeGPUMemory] = *resource.NewQuantity(template.InstanceType.GPUMemory, resource.DecimalSI)
++	node.Status.Capacity[mpscontext.ResourceVisenzeMPSContext] = *resource.NewQuantity(template.InstanceType.MPSContext, resource.DecimalSI)
++	node.Status.Allocatable = node.Status.Capacity
++
++	// NodeLabels
++	node.Labels = cloudprovider.JoinStringMaps(node.Labels, extractLabelsFromGroup(template.Tags))
++
++	// GenericLabels
++	node.Labels = cloudprovider.JoinStringMaps(node.Labels, buildGenericLabels(template, nodeName))
++
++	node.Spec.Taints = extractTaintsFromGroup(template.Tags)
++	node.Status.Conditions = cloudprovider.BuildReadyConditions()
++
++	klog.V(4).Infof("Node `%s` labels: %s", nodeName, stringutil.Stringify(node.Labels))
++	klog.V(4).Infof("Node `%s` taints: %s", nodeName, stringutil.Stringify(node.Spec.Taints))
++
++	return &node, nil
++}
++
++func buildGenericLabels(template *groupTemplate, nodeName string) map[string]string {
++	result := make(map[string]string)
++
++	result[kubeletapis.LabelArch] = cloudprovider.DefaultArch
++	result[kubeletapis.LabelOS] = cloudprovider.DefaultOS
++	result[apiv1.LabelInstanceType] = template.InstanceType.InstanceType
++	result[apiv1.LabelZoneRegion] = template.Region
++	result[apiv1.LabelZoneFailureDomain] = template.Zone
++	result[apiv1.LabelHostname] = nodeName
++
++	return result
++}
++
++func extractLabelsFromGroup(tags []*aws.Tag) map[string]string {
++	result := make(map[string]string)
++
++	for _, tag := range tags {
++		k := *tag.Key
++		v := *tag.Value
++		splits := strings.Split(k, "k8s.io/cluster-autoscaler/node-template/label/")
++		if len(splits) > 1 {
++			label := splits[1]
++			if label != "" {
++				result[label] = v
++			}
++		}
++	}
++
++	return result
++}
++
++func extractTaintsFromGroup(tags []*aws.Tag) []apiv1.Taint {
++	taints := make([]apiv1.Taint, 0)
++
++	for _, tag := range tags {
++		k := *tag.Key
++		v := *tag.Value
++		splits := strings.Split(k, "k8s.io/cluster-autoscaler/node-template/taint/")
++		if len(splits) > 1 {
++			values := strings.SplitN(v, ":", 2)
++			taints = append(taints, apiv1.Taint{
++				Key:    splits[1],
++				Value:  values[0],
++				Effect: apiv1.TaintEffect(values[1]),
++			})
++		}
++	}
++
++	return taints
++}
+diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go
+new file mode 100644
+index 000000000..648a559ad
+--- /dev/null
++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go
+@@ -0,0 +1,225 @@
++/*
++Copyright 2016 The Kubernetes Authors.
++Licensed under the Apache License, Version 2.0 (the "License");
++you may not use this file except in compliance with the License.
++You may obtain a copy of the License at
++    http://www.apache.org/licenses/LICENSE-2.0
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an "AS IS" BASIS,
++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++*/
++
++package spotinst
++
++import (
++	"context"
++	"errors"
++	"fmt"
++	"k8s.io/klog"
++	"regexp"
++	"strings"
++
++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
++	"github.com/spotinst/spotinst-sdk-go/spotinst"
++	apiv1 "k8s.io/api/core/v1"
++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
++	"k8s.io/kubernetes/pkg/scheduler/nodeinfo"
++)
++
++type Group struct {
++	manager *CloudManager
++	group   *aws.Group
++	groupID string
++	minSize int
++	maxSize int
++}
++
++// MaxSize returns maximum size of the node group.
++func (grp *Group) MaxSize() int {
++	return grp.maxSize
++}
++
++// MinSize returns minimum size of the node group.
++func (grp *Group) MinSize() int {
++	return grp.minSize
++}
++
++// TargetSize returns the current target size of the node group.
++func (grp *Group) TargetSize() (int, error) {
++	size, err := grp.manager.GetGroupSize(grp)
++	return int(size), err
++}
++
++// IncreaseSize increases the size of the node group.
++func (grp *Group) IncreaseSize(delta int) error {
++	if delta <= 0 {
++		return errors.New("size increase must be positive")
++	}
++	size, err := grp.manager.GetGroupSize(grp)
++	if err != nil {
++		return err
++	}
++	if int(size)+delta > grp.MaxSize() {
++		return fmt.Errorf("size increase too large - desired:%d max:%d", int(size)+delta, grp.MaxSize())
++	}
++	return grp.manager.SetGroupSize(grp, size+int64(delta))
++}
++
++// DeleteNodes deletes nodes from this node group.
++func (grp *Group) DeleteNodes(nodes []*apiv1.Node) error {
++	size, err := grp.manager.GetGroupSize(grp)
++	if err != nil {
++		return fmt.Errorf("error when deleting nodes, retrieving size of group %s failed: %v", grp.Id(), err)
++	}
++	if int(size) <= grp.MinSize() {
++		return errors.New("min size reached, nodes will not be deleted")
++	}
++	toBeDeleted := make([]string, 0)
++	for _, node := range nodes {
++		belongs, err := grp.Belongs(node)
++		if err != nil {
++			return fmt.Errorf("failed to check membership of node %s in group %s: %v", node.Name, grp.Id(), err)
++		}
++		if !belongs {
++			return fmt.Errorf("%s belongs to a different group than %s", node.Name, grp.Id())
++		}
++		instanceID, err := extractInstanceId(node.Spec.ProviderID)
++		if err != nil {
++			return fmt.Errorf("node %s's cloud provider ID is malformed: %v", node.Name, err)
++		}
++		toBeDeleted = append(toBeDeleted, instanceID)
++	}
++	return grp.manager.DeleteInstances(toBeDeleted)
++}
++
++// DecreaseTargetSize decreases the target size of the node group.
++func (grp *Group) DecreaseTargetSize(delta int) error {
++	if delta >= 0 {
++		return errors.New("size decrease size must be negative")
++	}
++	size, err := grp.manager.GetGroupSize(grp)
++	if err != nil {
++		return err
++	}
++	nodes, err := grp.Nodes()
++	if err != nil {
++		return err
++	}
++	if int(size)+delta < len(nodes) {
++		return fmt.Errorf("size decrease too large - desired:%d existing:%d", int(size)+delta, len(nodes))
++	}
++	return grp.manager.SetGroupSize(grp, size+int64(delta))
++}
++
++// Id returns an unique identifier of the node group.
++func (grp *Group) Id() string {
++	return grp.groupID
++}
++
++// Debug returns a string containing all information regarding this node group.
++func (grp *Group) Debug() string {
++	return fmt.Sprintf("%s (%d:%d)", grp.Id(), grp.MinSize(), grp.MaxSize())
++}
++
++// Nodes returns a list of all nodes that belong to this node group.
++func (grp *Group) Nodes() ([]cloudprovider.Instance, error) {
++	in := &aws.StatusGroupInput{
++		GroupID: spotinst.String(grp.Id()),
++	}
++	status, err := grp.manager.groupService.CloudProviderAWS().Status(context.Background(), in)
++	if err != nil {
++		return []cloudprovider.Instance{}, err
++	}
++	out := make([]cloudprovider.Instance, 0)
++	for _, instance := range status.Instances {
++		if instance.ID != nil && instance.AvailabilityZone != nil {
++			out = append(out, cloudprovider.Instance{Id: fmt.Sprintf("aws:///%s/%s", *instance.AvailabilityZone, *instance.ID)})
++		}
++	}
++	return out, nil
++}
++
++// TemplateNodeInfo returns a node template for this node group.
++func (grp *Group) TemplateNodeInfo() (*nodeinfo.NodeInfo, error) {
++	klog.Infof("No working nodes in node group %s, trying to generate from template", grp.Id())
++
++	template, err := grp.manager.buildGroupTemplate(grp.Id())
++	if err != nil {
++		return nil, err
++	}
++
++	node, err := grp.manager.buildNodeFromTemplate(grp, template)
++	if err != nil {
++		return nil, err
++	}
++
++	nodeInfo := nodeinfo.NewNodeInfo(cloudprovider.BuildKubeProxy(grp.Id()))
++	nodeInfo.SetNode(node)
++	return nodeInfo, nil
++}
++
++// Belongs returns true if the given node belongs to the NodeGroup.
++func (grp *Group) Belongs(node *apiv1.Node) (bool, error) {
++	instanceID, err := extractInstanceId(node.Spec.ProviderID)
++	if err != nil {
++		return false, err
++	}
++	group, err := grp.manager.GetGroupForInstance(instanceID)
++	if err != nil {
++		return false, err
++	}
++	if group == nil {
++		return false, fmt.Errorf("%s does not belong to a known group", node.Name)
++	}
++	return true, nil
++}
++
++// Exist checks if the node group really exists on the cloud provider side.
++func (grp *Group) Exist() bool {
++	return true
++}
++
++// Create creates the node group on the cloud provider side.
++func (grp *Group) Create() (cloudprovider.NodeGroup, error) {
++	return nil, cloudprovider.ErrAlreadyExist
++}
++
++// Delete deletes the node group on the cloud provider side.
++func (grp *Group) Delete() error {
++	return cloudprovider.ErrNotImplemented
++}
++
++// Autoprovisioned returns true if the node group is autoprovisioned.
++func (grp *Group) Autoprovisioned() bool {
++	return false
++}
++
++var (
++	spotinstProviderRE = regexp.MustCompile(`^spotinst\:\/\/\/[-0-9a-z]*\/[-0-9a-z]*$`)
++	awsProviderRE      = regexp.MustCompile(`^aws\:\/\/\/[-0-9a-z]*\/[-0-9a-z]*$`)
++)
++
++func extractInstanceId(providerID string) (string, error) {
++	var prefix string
++
++	if spotinstProviderRE.FindStringSubmatch(providerID) != nil {
++		prefix = "spotinst:///"
++	}
++
++	if awsProviderRE.FindStringSubmatch(providerID) != nil {
++		prefix = "aws:///"
++	}
++
++	if prefix == "" {
++		return "", fmt.Errorf("expected node provider ID to be one of the "+
++			"forms `spotinst:///<zone>/<instance-id>` or `aws:///<zone>/<instance-id>`, got `%s`", providerID)
++	}
++
++	parts := strings.Split(providerID[len(prefix):], "/")
++	instanceID := parts[1]
++
++	klog.Infof("Instance ID `%s` extracted from provider `%s`", instanceID, providerID)
++	return instanceID, nil
++}
+diff --git a/cluster-autoscaler/utils/gpumemory/gpumemory.go b/cluster-autoscaler/utils/gpumemory/gpumemory.go
+new file mode 100644
+index 000000000..74dad4198
+--- /dev/null
++++ b/cluster-autoscaler/utils/gpumemory/gpumemory.go
+@@ -0,0 +1,41 @@
++package gpumemory
++
++import (
++	apiv1 "k8s.io/api/core/v1"
++	"k8s.io/apimachinery/pkg/api/resource"
++)
++
++const (
++	// ResourceVisenzeGPUMemory is the name of the GPU Memory resource
++	ResourceVisenzeGPUMemory = "visenze.com/nvidia-gpu-memory"
++	// GPULabel is the label added to nodes with GPU resource by Visenze.
++	// If you're not scaling - this is probably the problem!
++	GPULabel = "accelerator"
++)
++
++// NodeHasGpuMemory returns true if a given node has GPU hardware
++func NodeHasGpuMemory(node *apiv1.Node) bool {
++	_, hasGpuLabel := node.Labels[GPULabel]
++	gpuAllocatable, hasGpuAllocatable := node.Status.Allocatable[ResourceVisenzeGPUMemory]
++	return hasGpuLabel || (hasGpuAllocatable && !gpuAllocatable.IsZero())
++}
++
++// PodRequestsGpuMemory returns true if a given pod has GPU Memory request
++func PodRequestsGpuMemory(pod *apiv1.Pod) bool {
++	for _, container := range pod.Spec.Containers {
++		if container.Resources.Requests != nil {
++			_, gpuMemoryFound := container.Resources.Requests[ResourceVisenzeGPUMemory]
++			if gpuMemoryFound {
++				return true
++			}
++		}
++	}
++	return false
++}
++
++// RequestInfo gives some information about hwo much GPU memory is needed
++type RequestInfo struct {
++	MaximumMemory resource.Quantity
++	TotalMemory   resource.Quantity
++	Pods          []*apiv1.Pod
++}
+diff --git a/cluster-autoscaler/utils/gpumemory/gpumemory_test.go b/cluster-autoscaler/utils/gpumemory/gpumemory_test.go
+new file mode 100644
+index 000000000..a69db0687
+--- /dev/null
++++ b/cluster-autoscaler/utils/gpumemory/gpumemory_test.go
+@@ -0,0 +1,83 @@
++package gpumemory
++
++import (
++	"testing"
++
++	"github.com/stretchr/testify/assert"
++	apiv1 "k8s.io/api/core/v1"
++	"k8s.io/apimachinery/pkg/api/resource"
++	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
++)
++
++func TestNodeHasGpuMemory(t *testing.T) {
++	gpuLabels := map[string]string{
++		GPULabel: "nvidia-tesla-k80",
++	}
++	nodeGpuReady := &apiv1.Node{
++		ObjectMeta: metav1.ObjectMeta{
++			Name:   "nodeGpuReady",
++			Labels: gpuLabels,
++		},
++		Status: apiv1.NodeStatus{
++			Capacity:    apiv1.ResourceList{},
++			Allocatable: apiv1.ResourceList{},
++		},
++	}
++	nodeGpuReady.Status.Allocatable[ResourceVisenzeGPUMemory] = *resource.NewQuantity(8e9, resource.DecimalSI)
++	nodeGpuReady.Status.Capacity[ResourceVisenzeGPUMemory] = *resource.NewQuantity(8e9, resource.DecimalSI)
++	assert.True(t, NodeHasGpuMemory(nodeGpuReady))
++
++	nodeGpuUnready := &apiv1.Node{
++		ObjectMeta: metav1.ObjectMeta{
++			Name:   "nodeGpuUnready",
++			Labels: gpuLabels,
++		},
++		Status: apiv1.NodeStatus{
++			Capacity:    apiv1.ResourceList{},
++			Allocatable: apiv1.ResourceList{},
++		},
++	}
++	assert.True(t, NodeHasGpuMemory(nodeGpuUnready))
++
++	nodeNoGpu := &apiv1.Node{
++		ObjectMeta: metav1.ObjectMeta{
++			Name:   "nodeNoGpu",
++			Labels: map[string]string{},
++		},
++		Status: apiv1.NodeStatus{
++			Capacity:    apiv1.ResourceList{},
++			Allocatable: apiv1.ResourceList{},
++		},
++	}
++	assert.False(t, NodeHasGpuMemory(nodeNoGpu))
++}
++
++func TestPodRequestsGpuMemory(t *testing.T) {
++	podNoGpu := &apiv1.Pod{
++		Spec: apiv1.PodSpec{
++			Containers: []apiv1.Container{
++				apiv1.Container{
++					Resources: apiv1.ResourceRequirements{
++						Requests: apiv1.ResourceList{
++							apiv1.ResourceCPU: *resource.NewQuantity(1, resource.DecimalSI),
++						},
++					},
++				},
++			},
++		},
++	}
++	podWithGpu := &apiv1.Pod{Spec: apiv1.PodSpec{Containers: []apiv1.Container{
++		apiv1.Container{
++			Resources: apiv1.ResourceRequirements{
++				Requests: apiv1.ResourceList{
++					apiv1.ResourceCPU:        *resource.NewQuantity(1, resource.DecimalSI),
++					ResourceVisenzeGPUMemory: *resource.NewQuantity(1, resource.DecimalSI),
++				},
++			},
++		},
++	}}}
++	podWithGpu.Spec.Containers[0].Resources.Requests[ResourceVisenzeGPUMemory] = *resource.NewQuantity(1, resource.DecimalSI)
++
++	assert.False(t, PodRequestsGpuMemory(podNoGpu))
++	assert.True(t, PodRequestsGpuMemory(podWithGpu))
++}
+diff --git a/cluster-autoscaler/utils/mpscontext/mpscontext.go b/cluster-autoscaler/utils/mpscontext/mpscontext.go
+new file mode 100644
+index 000000000..f01157f47
+--- /dev/null
++++ b/cluster-autoscaler/utils/mpscontext/mpscontext.go
+@@ -0,0 +1,6 @@
++package mpscontext
++
++// Custom resource for NVIDIA MPS context
++const (
++	ResourceVisenzeMPSContext = "visenze.com/nvidia-mps-context"
++)
+diff --git a/cluster-autoscaler/version/version.go b/cluster-autoscaler/version/version.go
+index b74536f7e..392964340 100644
+--- a/cluster-autoscaler/version/version.go
++++ b/cluster-autoscaler/version/version.go
+@@ -17,4 +17,4 @@ limitations under the License.
+ package version
+ 
+ // ClusterAutoscalerVersion contains version of CA.
+-const ClusterAutoscalerVersion = "1.17.4"
++const ClusterAutoscalerVersion = "1.17.5"
+diff --git a/patch/1.17.patch b/patch/1.17.patch
+new file mode 100644
+index 000000000..2822dfd06
+--- /dev/null
++++ b/patch/1.17.patch
+@@ -0,0 +1,3225 @@
++diff --git a/Jenkinsfile b/Jenkinsfile
++new file mode 100644
++index 000000000..bb612ed8b
++--- /dev/null
+++++ b/Jenkinsfile
++@@ -0,0 +1,107 @@
+++
+++// throttle concurrent build
+++properties([[$class: 'ThrottleJobProperty', categories: [], limitOneJobWithMatchingParams: false, maxConcurrentPerNode: 1, maxConcurrentTotal: 1, paramsToUseForLimit: '', throttleEnabled: true, throttleOption: 'project']])
+++
+++library(identifier: "visenze-lib@${params['VISENZE_LIB_BRANCH'] ?: 'master'}", changelog: false)
+++
+++pipeline {
+++  agent {
+++    label "${params.AGENT_LABEL ?: 'build'}"
+++  }
+++
+++  options {
+++    ansiColor('xterm')
+++  }
+++
+++  stages {
+++    stage('Checkout') {
+++      steps {
+++        checkout([
+++          $class: 'GitSCM',
+++          branches: scm.branches,
+++          doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
+++          extensions: [
+++            [
+++              $class: 'CloneOption',
+++              noTags: true,
+++              reference: '',
+++              timeout: 60
+++            ],
+++            [
+++              $class: 'SubmoduleOption',
+++              disableSubmodules: false,
+++              parentCredentials: true,
+++              recursiveSubmodules: true,
+++              trackingSubmodules: true,
+++              reference: '',
+++              timeout: 60
+++            ],
+++            [$class: 'CleanBeforeCheckout']
+++          ],
+++          userRemoteConfigs: scm.userRemoteConfigs
+++        ])
+++      }
+++    }
+++
+++    stage('Test') {
+++      when {
+++        expression {
+++          return canRun()
+++        }
+++      }
+++      steps {
+++        script {
+++          dir('cluster-autoscaler') {
+++            sh('make test-in-docker')
+++          }
+++        }
+++      }
+++    }
+++
+++    stage('Compile') {
+++      when {
+++        expression {
+++          return canRun()
+++        }
+++      }
+++      steps {
+++        script {
+++          dir('cluster-autoscaler') {
+++            sh('make build-in-docker')
+++          }
+++        }
+++      }
+++    }
+++
+++    stage('Docker') {
+++      when {
+++        expression {
+++          return canRun()
+++        }
+++      }
+++      steps {
+++        script {
+++          dir('cluster-autoscaler') {
+++            def version = sh(script: "grep ClusterAutoscalerVersion version/version.go",
+++                             returnStdout: true).split('"')[-2]
+++            def registry = 'visenze'
+++            withEnv([
+++              "REGISTRY=${registry}",
+++              "TAG=${version}"
+++            ]) {
+++              sh('make make-image')
+++              docker.withRegistry('', 'docker-hub-credential') {
+++                def image = docker.image("${registry}/cluster-autoscaler:${version}")
+++                image.push()
+++              }
+++            }
+++          }
+++        }
+++      }
+++    }
+++  }
+++}
+++
+++def canRun() {
+++  return env.BRANCH_NAME.startsWith('release-') || env.BRANCH_NAME == 'master'
+++} 
++diff --git a/cluster-autoscaler/Makefile b/cluster-autoscaler/Makefile
++index 21ed38ef5..91dd4d043 100644
++--- a/cluster-autoscaler/Makefile
+++++ b/cluster-autoscaler/Makefile
++@@ -3,7 +3,7 @@ all: build
++ TAG?=dev
++ FLAGS=
++ LDFLAGS?=-s
++-ENVVAR=CGO_ENABLED=0 GO111MODULE=off
+++ENVVAR=CGO_ENABLED=0 GO111MODULE=on
++ GOOS?=linux
++ REGISTRY?=staging-k8s.gcr.io
++ ifdef BUILD_TAGS
++@@ -29,7 +29,7 @@ build-binary: clean deps
++ 	$(ENVVAR) GOOS=$(GOOS) go build -o cluster-autoscaler ${LDFLAGS_FLAG} ${TAGS_FLAG}
++ 
++ test-unit: clean deps build
++-	GO111MODULE=off go test --test.short -race ./... ${TAGS_FLAG}
+++	GO111MODULE=on go test --test.short -race ./... ${TAGS_FLAG}
++ 
++ dev-release: build-binary execute-release
++ 	@echo "Release ${TAG}${FOR_PROVIDER} completed"
++@@ -70,7 +70,7 @@ container: build-in-docker make-image
++ 	@echo "Created in-docker image ${TAG}${FOR_PROVIDER}"
++ 
++ test-in-docker: clean docker-builder
++-	docker run -v `pwd`:/gopath/src/k8s.io/autoscaler/cluster-autoscaler/ autoscaling-builder:latest bash -c 'cd /gopath/src/k8s.io/autoscaler/cluster-autoscaler && GO111MODULE=off go test -race ./... ${TAGS_FLAG}'
+++	docker run -v `pwd`:/gopath/src/k8s.io/autoscaler/cluster-autoscaler/ autoscaling-builder:latest bash -c 'cd /gopath/src/k8s.io/autoscaler/cluster-autoscaler && go test -race ./... ${TAGS_FLAG}'
++ 
++ .PHONY: all deps build test-unit clean format execute-release dev-release docker-builder build-in-docker release generate
++ 
++diff --git a/cluster-autoscaler/cloudprovider/builder/builder_all.go b/cluster-autoscaler/cloudprovider/builder/builder_all.go
++index 37fa63c84..1475a8fa4 100644
++--- a/cluster-autoscaler/cloudprovider/builder/builder_all.go
+++++ b/cluster-autoscaler/cloudprovider/builder/builder_all.go
++@@ -29,6 +29,7 @@ import (
++ 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/gce"
++ 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/magnum"
++ 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/packet"
+++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/spotinst"
++ 	"k8s.io/autoscaler/cluster-autoscaler/config"
++ )
++ 
++@@ -41,6 +42,7 @@ var AvailableCloudProviders = []string{
++ 	cloudprovider.BaiducloudProviderName,
++ 	cloudprovider.MagnumProviderName,
++ 	cloudprovider.DigitalOceanProviderName,
+++	cloudprovider.SpotinstProviderName,
++ 	clusterapi.ProviderName,
++ }
++ 
++@@ -67,6 +69,8 @@ func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGro
++ 		return packet.BuildPacket(opts, do, rl)
++ 	case clusterapi.ProviderName:
++ 		return clusterapi.BuildClusterAPI(opts, do, rl)
+++  case cloudprovider.SpotinstProviderName:
+++		return spotinst.BuildSpotinst(opts, do, rl)
++ 	}
++ 	return nil
++ }
++diff --git a/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go b/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go
++new file mode 100644
++index 000000000..62b1e1744
++--- /dev/null
+++++ b/cluster-autoscaler/cloudprovider/builder/builder_spotinst.go
++@@ -0,0 +1,39 @@
+++// +build spotinst
+++
+++/*
+++Copyright 2018 The Kubernetes Authors.
+++Licensed under the Apache License, Version 2.0 (the "License");
+++you may not use this file except in compliance with the License.
+++You may obtain a copy of the License at
+++    http://www.apache.org/licenses/LICENSE-2.0
+++Unless required by applicable law or agreed to in writing, software
+++distributed under the License is distributed on an "AS IS" BASIS,
+++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++See the License for the specific language governing permissions and
+++limitations under the License.
+++*/
+++
+++package builder
+++
+++import (
+++"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+++"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/spotinst"
+++"k8s.io/autoscaler/cluster-autoscaler/config"
+++)
+++
+++// AvailableCloudProviders supported by the cloud provider builder.
+++var AvailableCloudProviders = []string{
+++	spotinst.ProviderName,
+++}
+++
+++// DefaultCloudProvider for Spotinst-only build is spotinst.
+++const DefaultCloudProvider = spotinst.ProviderName
+++
+++func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
+++	switch opts.CloudProviderName {
+++	case spotinst.ProviderName:
+++		return spotinst.BuildSpotinst(opts, do, rl)
+++	}
+++
+++	return nil
+++}
++diff --git a/cluster-autoscaler/cloudprovider/cloud_provider.go b/cluster-autoscaler/cloudprovider/cloud_provider.go
++index d9d50d04b..c2cdb6df9 100644
++--- a/cluster-autoscaler/cloudprovider/cloud_provider.go
+++++ b/cluster-autoscaler/cloudprovider/cloud_provider.go
++@@ -43,6 +43,8 @@ const (
++ 	MagnumProviderName = "magnum"
++ 	// KubemarkProviderName gets the provider name of kubemark
++ 	KubemarkProviderName = "kubemark"
+++	// SpotinstProviderName gets the provider name of aws
+++	SpotinstProviderName = "spotinst"
++ )
++ 
++ // CloudProvider contains configuration info and functions for interacting with
++diff --git a/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go b/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go
++new file mode 100644
++index 000000000..8f772e57e
++--- /dev/null
+++++ b/cluster-autoscaler/cloudprovider/spotinst/aws_ec2_instance_types.go
++@@ -0,0 +1,1510 @@
+++/*
+++Copyright 2017 The Kubernetes Authors.
+++Licensed under the Apache License, Version 2.0 (the "License");
+++you may not use this file except in compliance with the License.
+++You may obtain a copy of the License at
+++    http://www.apache.org/licenses/LICENSE-2.0
+++Unless required by applicable law or agreed to in writing, software
+++distributed under the License is distributed on an "AS IS" BASIS,
+++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++See the License for the specific language governing permissions and
+++limitations under the License.
+++*/
+++
+++// This file was generated by go generate; DO NOT EDIT
+++
+++package spotinst
+++
+++type instanceType struct {
+++	InstanceType string
+++	VCPU         int64
+++	MemoryMb     int64
+++	GPU          int64
+++	GPUMemory    int64
+++	MPSContext   int64
+++}
+++
+++// InstanceTypes is a map of ec2 resources
+++var InstanceTypes = map[string]*instanceType{
+++	"a1": {
+++		InstanceType: "a1",
+++		VCPU:         16,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"a1.2xlarge": {
+++		InstanceType: "a1.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"a1.4xlarge": {
+++		InstanceType: "a1.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"a1.large": {
+++		InstanceType: "a1.large",
+++		VCPU:         2,
+++		MemoryMb:     4096,
+++		GPU:          0,
+++	},
+++	"a1.medium": {
+++		InstanceType: "a1.medium",
+++		VCPU:         1,
+++		MemoryMb:     2048,
+++		GPU:          0,
+++	},
+++	"a1.xlarge": {
+++		InstanceType: "a1.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"c1.medium": {
+++		InstanceType: "c1.medium",
+++		VCPU:         2,
+++		MemoryMb:     1740,
+++		GPU:          0,
+++	},
+++	"c1.xlarge": {
+++		InstanceType: "c1.xlarge",
+++		VCPU:         8,
+++		MemoryMb:     7168,
+++		GPU:          0,
+++	},
+++	"c3": {
+++		InstanceType: "c3",
+++		VCPU:         32,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"c3.2xlarge": {
+++		InstanceType: "c3.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     15360,
+++		GPU:          0,
+++	},
+++	"c3.4xlarge": {
+++		InstanceType: "c3.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     30720,
+++		GPU:          0,
+++	},
+++	"c3.8xlarge": {
+++		InstanceType: "c3.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     61440,
+++		GPU:          0,
+++	},
+++	"c3.large": {
+++		InstanceType: "c3.large",
+++		VCPU:         2,
+++		MemoryMb:     3840,
+++		GPU:          0,
+++	},
+++	"c3.xlarge": {
+++		InstanceType: "c3.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     7680,
+++		GPU:          0,
+++	},
+++	"c4": {
+++		InstanceType: "c4",
+++		VCPU:         36,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"c4.2xlarge": {
+++		InstanceType: "c4.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     15360,
+++		GPU:          0,
+++	},
+++	"c4.4xlarge": {
+++		InstanceType: "c4.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     30720,
+++		GPU:          0,
+++	},
+++	"c4.8xlarge": {
+++		InstanceType: "c4.8xlarge",
+++		VCPU:         36,
+++		MemoryMb:     61440,
+++		GPU:          0,
+++	},
+++	"c4.large": {
+++		InstanceType: "c4.large",
+++		VCPU:         2,
+++		MemoryMb:     3840,
+++		GPU:          0,
+++	},
+++	"c4.xlarge": {
+++		InstanceType: "c4.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     7680,
+++		GPU:          0,
+++	},
+++	"c5": {
+++		InstanceType: "c5",
+++		VCPU:         72,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"c5.12xlarge": {
+++		InstanceType: "c5.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     98304,
+++		GPU:          0,
+++	},
+++	"c5.18xlarge": {
+++		InstanceType: "c5.18xlarge",
+++		VCPU:         72,
+++		MemoryMb:     147456,
+++		GPU:          0,
+++	},
+++	"c5.24xlarge": {
+++		InstanceType: "c5.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"c5.2xlarge": {
+++		InstanceType: "c5.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"c5.4xlarge": {
+++		InstanceType: "c5.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"c5.9xlarge": {
+++		InstanceType: "c5.9xlarge",
+++		VCPU:         36,
+++		MemoryMb:     73728,
+++		GPU:          0,
+++	},
+++	"c5.large": {
+++		InstanceType: "c5.large",
+++		VCPU:         2,
+++		MemoryMb:     4096,
+++		GPU:          0,
+++	},
+++	"c5.metal": {
+++		InstanceType: "c5.metal",
+++		VCPU:         96,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"c5.xlarge": {
+++		InstanceType: "c5.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"c5d": {
+++		InstanceType: "c5d",
+++		VCPU:         72,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"c5d.18xlarge": {
+++		InstanceType: "c5d.18xlarge",
+++		VCPU:         72,
+++		MemoryMb:     147456,
+++		GPU:          0,
+++	},
+++	"c5d.2xlarge": {
+++		InstanceType: "c5d.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"c5d.4xlarge": {
+++		InstanceType: "c5d.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"c5d.9xlarge": {
+++		InstanceType: "c5d.9xlarge",
+++		VCPU:         36,
+++		MemoryMb:     73728,
+++		GPU:          0,
+++	},
+++	"c5d.large": {
+++		InstanceType: "c5d.large",
+++		VCPU:         2,
+++		MemoryMb:     4096,
+++		GPU:          0,
+++	},
+++	"c5d.xlarge": {
+++		InstanceType: "c5d.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"c5n": {
+++		InstanceType: "c5n",
+++		VCPU:         72,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"c5n.18xlarge": {
+++		InstanceType: "c5n.18xlarge",
+++		VCPU:         72,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"c5n.2xlarge": {
+++		InstanceType: "c5n.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     21504,
+++		GPU:          0,
+++	},
+++	"c5n.4xlarge": {
+++		InstanceType: "c5n.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     43008,
+++		GPU:          0,
+++	},
+++	"c5n.9xlarge": {
+++		InstanceType: "c5n.9xlarge",
+++		VCPU:         36,
+++		MemoryMb:     98304,
+++		GPU:          0,
+++	},
+++	"c5n.large": {
+++		InstanceType: "c5n.large",
+++		VCPU:         2,
+++		MemoryMb:     5376,
+++		GPU:          0,
+++	},
+++	"c5n.xlarge": {
+++		InstanceType: "c5n.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     10752,
+++		GPU:          0,
+++	},
+++	"cc2.8xlarge": {
+++		InstanceType: "cc2.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     61952,
+++		GPU:          0,
+++	},
+++	"cg1.4xlarge": {
+++		InstanceType: "cg1.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     23040,
+++		GPU:          0,
+++	},
+++	"cr1.8xlarge": {
+++		InstanceType: "cr1.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"d2": {
+++		InstanceType: "d2",
+++		VCPU:         36,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"d2.2xlarge": {
+++		InstanceType: "d2.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     62464,
+++		GPU:          0,
+++	},
+++	"d2.4xlarge": {
+++		InstanceType: "d2.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"d2.8xlarge": {
+++		InstanceType: "d2.8xlarge",
+++		VCPU:         36,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"d2.xlarge": {
+++		InstanceType: "d2.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     31232,
+++		GPU:          0,
+++	},
+++	"f1": {
+++		InstanceType: "f1",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"f1.16xlarge": {
+++		InstanceType: "f1.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     999424,
+++		GPU:          0,
+++	},
+++	"f1.2xlarge": {
+++		InstanceType: "f1.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"f1.4xlarge": {
+++		InstanceType: "f1.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"g2": {
+++		InstanceType: "g2",
+++		VCPU:         32,
+++		MemoryMb:     0,
+++		GPU:          4,
+++		MPSContext:   16,
+++	},
+++	"g2.2xlarge": {
+++		InstanceType: "g2.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     15360,
+++		GPU:          1,
+++		MPSContext:   16,
+++	},
+++	"g2.8xlarge": {
+++		InstanceType: "g2.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     61440,
+++		GPU:          4,
+++		MPSContext:   16,
+++	},
+++	"g3": {
+++		InstanceType: "g3",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          4,
+++		GPUMemory:    31931236352,
+++		MPSContext:   16,
+++	},
+++	"g3.16xlarge": {
+++		InstanceType: "g3.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     499712,
+++		GPU:          4,
+++		GPUMemory:    31931236352,
+++		MPSContext:   16,
+++	},
+++	"g3.4xlarge": {
+++		InstanceType: "g3.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     124928,
+++		GPU:          1,
+++		GPUMemory:    7982809088,
+++		MPSContext:   16,
+++	},
+++	"g3.8xlarge": {
+++		InstanceType: "g3.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          2,
+++		GPUMemory:    15965618176,
+++		MPSContext:   16,
+++	},
+++	"g3s.xlarge": {
+++		InstanceType: "g3s.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     31232,
+++		GPU:          1,
+++		GPUMemory:    7982809088,
+++		MPSContext:   16,
+++	},
+++	"h1": {
+++		InstanceType: "h1",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"h1.16xlarge": {
+++		InstanceType: "h1.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"h1.2xlarge": {
+++		InstanceType: "h1.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"h1.4xlarge": {
+++		InstanceType: "h1.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"h1.8xlarge": {
+++		InstanceType: "h1.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"hs1.8xlarge": {
+++		InstanceType: "hs1.8xlarge",
+++		VCPU:         17,
+++		MemoryMb:     119808,
+++		GPU:          0,
+++	},
+++	"i2": {
+++		InstanceType: "i2",
+++		VCPU:         32,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"i2.2xlarge": {
+++		InstanceType: "i2.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     62464,
+++		GPU:          0,
+++	},
+++	"i2.4xlarge": {
+++		InstanceType: "i2.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"i2.8xlarge": {
+++		InstanceType: "i2.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"i2.xlarge": {
+++		InstanceType: "i2.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     31232,
+++		GPU:          0,
+++	},
+++	"i3": {
+++		InstanceType: "i3",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"i3.16xlarge": {
+++		InstanceType: "i3.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     499712,
+++		GPU:          0,
+++	},
+++	"i3.2xlarge": {
+++		InstanceType: "i3.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     62464,
+++		GPU:          0,
+++	},
+++	"i3.4xlarge": {
+++		InstanceType: "i3.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"i3.8xlarge": {
+++		InstanceType: "i3.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"i3.large": {
+++		InstanceType: "i3.large",
+++		VCPU:         2,
+++		MemoryMb:     15616,
+++		GPU:          0,
+++	},
+++	"i3.metal": {
+++		InstanceType: "i3.metal",
+++		VCPU:         72,
+++		MemoryMb:     524288,
+++		GPU:          0,
+++	},
+++	"i3.xlarge": {
+++		InstanceType: "i3.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     31232,
+++		GPU:          0,
+++	},
+++	"i3en": {
+++		InstanceType: "i3en",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"i3en.12xlarge": {
+++		InstanceType: "i3en.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"i3en.24xlarge": {
+++		InstanceType: "i3en.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"i3en.2xlarge": {
+++		InstanceType: "i3en.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"i3en.3xlarge": {
+++		InstanceType: "i3en.3xlarge",
+++		VCPU:         12,
+++		MemoryMb:     98304,
+++		GPU:          0,
+++	},
+++	"i3en.6xlarge": {
+++		InstanceType: "i3en.6xlarge",
+++		VCPU:         24,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"i3en.large": {
+++		InstanceType: "i3en.large",
+++		VCPU:         2,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"i3en.xlarge": {
+++		InstanceType: "i3en.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"m1.large": {
+++		InstanceType: "m1.large",
+++		VCPU:         2,
+++		MemoryMb:     7680,
+++		GPU:          0,
+++	},
+++	"m1.medium": {
+++		InstanceType: "m1.medium",
+++		VCPU:         1,
+++		MemoryMb:     3840,
+++		GPU:          0,
+++	},
+++	"m1.small": {
+++		InstanceType: "m1.small",
+++		VCPU:         1,
+++		MemoryMb:     1740,
+++		GPU:          0,
+++	},
+++	"m1.xlarge": {
+++		InstanceType: "m1.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     15360,
+++		GPU:          0,
+++	},
+++	"m2.2xlarge": {
+++		InstanceType: "m2.2xlarge",
+++		VCPU:         4,
+++		MemoryMb:     35020,
+++		GPU:          0,
+++	},
+++	"m2.4xlarge": {
+++		InstanceType: "m2.4xlarge",
+++		VCPU:         8,
+++		MemoryMb:     70041,
+++		GPU:          0,
+++	},
+++	"m2.xlarge": {
+++		InstanceType: "m2.xlarge",
+++		VCPU:         2,
+++		MemoryMb:     17510,
+++		GPU:          0,
+++	},
+++	"m3": {
+++		InstanceType: "m3",
+++		VCPU:         8,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"m3.2xlarge": {
+++		InstanceType: "m3.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     30720,
+++		GPU:          0,
+++	},
+++	"m3.large": {
+++		InstanceType: "m3.large",
+++		VCPU:         2,
+++		MemoryMb:     7680,
+++		GPU:          0,
+++	},
+++	"m3.medium": {
+++		InstanceType: "m3.medium",
+++		VCPU:         1,
+++		MemoryMb:     3840,
+++		GPU:          0,
+++	},
+++	"m3.xlarge": {
+++		InstanceType: "m3.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     15360,
+++		GPU:          0,
+++	},
+++	"m4": {
+++		InstanceType: "m4",
+++		VCPU:         40,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"m4.10xlarge": {
+++		InstanceType: "m4.10xlarge",
+++		VCPU:         40,
+++		MemoryMb:     163840,
+++		GPU:          0,
+++	},
+++	"m4.16xlarge": {
+++		InstanceType: "m4.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"m4.2xlarge": {
+++		InstanceType: "m4.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"m4.4xlarge": {
+++		InstanceType: "m4.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"m4.large": {
+++		InstanceType: "m4.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"m4.xlarge": {
+++		InstanceType: "m4.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"m5": {
+++		InstanceType: "m5",
+++		VCPU:         96,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"m5.12xlarge": {
+++		InstanceType: "m5.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"m5.16xlarge": {
+++		InstanceType: "m5.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"m5.24xlarge": {
+++		InstanceType: "m5.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"m5.2xlarge": {
+++		InstanceType: "m5.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"m5.4xlarge": {
+++		InstanceType: "m5.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"m5.8xlarge": {
+++		InstanceType: "m5.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"m5.large": {
+++		InstanceType: "m5.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"m5.metal": {
+++		InstanceType: "m5.metal",
+++		VCPU:         96,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"m5.xlarge": {
+++		InstanceType: "m5.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"m5a.12xlarge": {
+++		InstanceType: "m5a.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"m5a.16xlarge": {
+++		InstanceType: "m5a.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"m5a.24xlarge": {
+++		InstanceType: "m5a.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"m5a.2xlarge": {
+++		InstanceType: "m5a.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"m5a.4xlarge": {
+++		InstanceType: "m5a.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"m5a.8xlarge": {
+++		InstanceType: "m5a.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"m5a.large": {
+++		InstanceType: "m5a.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"m5a.xlarge": {
+++		InstanceType: "m5a.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"m5ad.12xlarge": {
+++		InstanceType: "m5ad.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"m5ad.24xlarge": {
+++		InstanceType: "m5ad.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"m5ad.2xlarge": {
+++		InstanceType: "m5ad.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"m5ad.4xlarge": {
+++		InstanceType: "m5ad.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"m5ad.large": {
+++		InstanceType: "m5ad.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"m5ad.xlarge": {
+++		InstanceType: "m5ad.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"m5d": {
+++		InstanceType: "m5d",
+++		VCPU:         96,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"m5d.12xlarge": {
+++		InstanceType: "m5d.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"m5d.16xlarge": {
+++		InstanceType: "m5d.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"m5d.24xlarge": {
+++		InstanceType: "m5d.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"m5d.2xlarge": {
+++		InstanceType: "m5d.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"m5d.4xlarge": {
+++		InstanceType: "m5d.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"m5d.8xlarge": {
+++		InstanceType: "m5d.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"m5d.large": {
+++		InstanceType: "m5d.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"m5d.metal": {
+++		InstanceType: "m5d.metal",
+++		VCPU:         96,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"m5d.xlarge": {
+++		InstanceType: "m5d.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"p2": {
+++		InstanceType: "p2",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          16,
+++		GPUMemory:    12000000000, // Rough estimate of 12 GB
+++		MPSContext:   16,
+++	},
+++	"p2.16xlarge": {
+++		InstanceType: "p2.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     786432,
+++		GPU:          16,
+++		GPUMemory:    192000000000,
+++		MPSContext:   16,
+++	},
+++	"p2.8xlarge": {
+++		InstanceType: "p2.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     499712,
+++		GPU:          8,
+++		GPUMemory:    96000000000,
+++		MPSContext:   16,
+++	},
+++	"p2.xlarge": {
+++		InstanceType: "p2.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     62464,
+++		GPU:          1,
+++		GPUMemory:    12000000000,
+++		MPSContext:   16,
+++	},
+++	"p3": {
+++		InstanceType: "p3",
+++		VCPU:         64,
+++		MemoryMb:     499712,
+++		GPU:          8,
+++		GPUMemory:    16000000000,
+++		MPSContext:   48,
+++	},
+++	"p3.16xlarge": {
+++		InstanceType: "p3.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     499712,
+++		GPU:          8,
+++		GPUMemory:    128000000000,
+++		MPSContext:   48,
+++	},
+++	"p3.2xlarge": {
+++		InstanceType: "p3.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     62464,
+++		GPU:          1,
+++		GPUMemory:    16000000000,
+++		MPSContext:   48,
+++	},
+++	"p3.8xlarge": {
+++		InstanceType: "p3.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          4,
+++		GPUMemory:    64000000000,
+++		MPSContext:   48,
+++	},
+++	"r3": {
+++		InstanceType: "r3",
+++		VCPU:         32,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"r3.2xlarge": {
+++		InstanceType: "r3.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     62464,
+++		GPU:          0,
+++	},
+++	"r3.4xlarge": {
+++		InstanceType: "r3.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"r3.8xlarge": {
+++		InstanceType: "r3.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"r3.large": {
+++		InstanceType: "r3.large",
+++		VCPU:         2,
+++		MemoryMb:     15616,
+++		GPU:          0,
+++	},
+++	"r3.xlarge": {
+++		InstanceType: "r3.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     31232,
+++		GPU:          0,
+++	},
+++	"r4": {
+++		InstanceType: "r4",
+++		VCPU:         64,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"r4.16xlarge": {
+++		InstanceType: "r4.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     499712,
+++		GPU:          0,
+++	},
+++	"r4.2xlarge": {
+++		InstanceType: "r4.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     62464,
+++		GPU:          0,
+++	},
+++	"r4.4xlarge": {
+++		InstanceType: "r4.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"r4.8xlarge": {
+++		InstanceType: "r4.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"r4.large": {
+++		InstanceType: "r4.large",
+++		VCPU:         2,
+++		MemoryMb:     15616,
+++		GPU:          0,
+++	},
+++	"r4.xlarge": {
+++		InstanceType: "r4.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     31232,
+++		GPU:          0,
+++	},
+++	"r5": {
+++		InstanceType: "r5",
+++		VCPU:         96,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"r5.12xlarge": {
+++		InstanceType: "r5.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"r5.16xlarge": {
+++		InstanceType: "r5.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     524288,
+++		GPU:          0,
+++	},
+++	"r5.24xlarge": {
+++		InstanceType: "r5.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"r5.2xlarge": {
+++		InstanceType: "r5.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"r5.4xlarge": {
+++		InstanceType: "r5.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"r5.8xlarge": {
+++		InstanceType: "r5.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"r5.large": {
+++		InstanceType: "r5.large",
+++		VCPU:         2,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"r5.metal": {
+++		InstanceType: "r5.metal",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"r5.xlarge": {
+++		InstanceType: "r5.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"r5a.12xlarge": {
+++		InstanceType: "r5a.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"r5a.16xlarge": {
+++		InstanceType: "r5a.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     524288,
+++		GPU:          0,
+++	},
+++	"r5a.24xlarge": {
+++		InstanceType: "r5a.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"r5a.2xlarge": {
+++		InstanceType: "r5a.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"r5a.4xlarge": {
+++		InstanceType: "r5a.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"r5a.8xlarge": {
+++		InstanceType: "r5a.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"r5a.large": {
+++		InstanceType: "r5a.large",
+++		VCPU:         2,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"r5a.xlarge": {
+++		InstanceType: "r5a.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"r5ad.12xlarge": {
+++		InstanceType: "r5ad.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"r5ad.24xlarge": {
+++		InstanceType: "r5ad.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"r5ad.2xlarge": {
+++		InstanceType: "r5ad.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"r5ad.4xlarge": {
+++		InstanceType: "r5ad.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"r5ad.large": {
+++		InstanceType: "r5ad.large",
+++		VCPU:         2,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"r5ad.xlarge": {
+++		InstanceType: "r5ad.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"r5d": {
+++		InstanceType: "r5d",
+++		VCPU:         96,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"r5d.12xlarge": {
+++		InstanceType: "r5d.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"r5d.16xlarge": {
+++		InstanceType: "r5d.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     524288,
+++		GPU:          0,
+++	},
+++	"r5d.24xlarge": {
+++		InstanceType: "r5d.24xlarge",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"r5d.2xlarge": {
+++		InstanceType: "r5d.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"r5d.4xlarge": {
+++		InstanceType: "r5d.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     131072,
+++		GPU:          0,
+++	},
+++	"r5d.8xlarge": {
+++		InstanceType: "r5d.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     262144,
+++		GPU:          0,
+++	},
+++	"r5d.large": {
+++		InstanceType: "r5d.large",
+++		VCPU:         2,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"r5d.metal": {
+++		InstanceType: "r5d.metal",
+++		VCPU:         96,
+++		MemoryMb:     786432,
+++		GPU:          0,
+++	},
+++	"r5d.xlarge": {
+++		InstanceType: "r5d.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"t1.micro": {
+++		InstanceType: "t1.micro",
+++		VCPU:         1,
+++		MemoryMb:     627,
+++		GPU:          0,
+++	},
+++	"t2.2xlarge": {
+++		InstanceType: "t2.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"t2.large": {
+++		InstanceType: "t2.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"t2.medium": {
+++		InstanceType: "t2.medium",
+++		VCPU:         2,
+++		MemoryMb:     4096,
+++		GPU:          0,
+++	},
+++	"t2.micro": {
+++		InstanceType: "t2.micro",
+++		VCPU:         1,
+++		MemoryMb:     1024,
+++		GPU:          0,
+++	},
+++	"t2.nano": {
+++		InstanceType: "t2.nano",
+++		VCPU:         1,
+++		MemoryMb:     512,
+++		GPU:          0,
+++	},
+++	"t2.small": {
+++		InstanceType: "t2.small",
+++		VCPU:         1,
+++		MemoryMb:     2048,
+++		GPU:          0,
+++	},
+++	"t2.xlarge": {
+++		InstanceType: "t2.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"t3.2xlarge": {
+++		InstanceType: "t3.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"t3.large": {
+++		InstanceType: "t3.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"t3.medium": {
+++		InstanceType: "t3.medium",
+++		VCPU:         2,
+++		MemoryMb:     4096,
+++		GPU:          0,
+++	},
+++	"t3.micro": {
+++		InstanceType: "t3.micro",
+++		VCPU:         2,
+++		MemoryMb:     1024,
+++		GPU:          0,
+++	},
+++	"t3.nano": {
+++		InstanceType: "t3.nano",
+++		VCPU:         2,
+++		MemoryMb:     512,
+++		GPU:          0,
+++	},
+++	"t3.small": {
+++		InstanceType: "t3.small",
+++		VCPU:         2,
+++		MemoryMb:     2048,
+++		GPU:          0,
+++	},
+++	"t3.xlarge": {
+++		InstanceType: "t3.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"t3a.2xlarge": {
+++		InstanceType: "t3a.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++	"t3a.large": {
+++		InstanceType: "t3a.large",
+++		VCPU:         2,
+++		MemoryMb:     8192,
+++		GPU:          0,
+++	},
+++	"t3a.medium": {
+++		InstanceType: "t3a.medium",
+++		VCPU:         2,
+++		MemoryMb:     4096,
+++		GPU:          0,
+++	},
+++	"t3a.micro": {
+++		InstanceType: "t3a.micro",
+++		VCPU:         2,
+++		MemoryMb:     1024,
+++		GPU:          0,
+++	},
+++	"t3a.nano": {
+++		InstanceType: "t3a.nano",
+++		VCPU:         2,
+++		MemoryMb:     512,
+++		GPU:          0,
+++	},
+++	"t3a.small": {
+++		InstanceType: "t3a.small",
+++		VCPU:         2,
+++		MemoryMb:     2048,
+++		GPU:          0,
+++	},
+++	"t3a.xlarge": {
+++		InstanceType: "t3a.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"u-12tb1": {
+++		InstanceType: "u-12tb1",
+++		VCPU:         448,
+++		MemoryMb:     12582912,
+++		GPU:          0,
+++	},
+++	"u-6tb1": {
+++		InstanceType: "u-6tb1",
+++		VCPU:         448,
+++		MemoryMb:     6291456,
+++		GPU:          0,
+++	},
+++	"u-9tb1": {
+++		InstanceType: "u-9tb1",
+++		VCPU:         448,
+++		MemoryMb:     9437184,
+++		GPU:          0,
+++	},
+++	"x1": {
+++		InstanceType: "x1",
+++		VCPU:         128,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"x1.16xlarge": {
+++		InstanceType: "x1.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     999424,
+++		GPU:          0,
+++	},
+++	"x1.32xlarge": {
+++		InstanceType: "x1.32xlarge",
+++		VCPU:         128,
+++		MemoryMb:     1998848,
+++		GPU:          0,
+++	},
+++	"x1e": {
+++		InstanceType: "x1e",
+++		VCPU:         128,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"x1e.16xlarge": {
+++		InstanceType: "x1e.16xlarge",
+++		VCPU:         64,
+++		MemoryMb:     1998848,
+++		GPU:          0,
+++	},
+++	"x1e.2xlarge": {
+++		InstanceType: "x1e.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     249856,
+++		GPU:          0,
+++	},
+++	"x1e.32xlarge": {
+++		InstanceType: "x1e.32xlarge",
+++		VCPU:         128,
+++		MemoryMb:     3997696,
+++		GPU:          0,
+++	},
+++	"x1e.4xlarge": {
+++		InstanceType: "x1e.4xlarge",
+++		VCPU:         16,
+++		MemoryMb:     499712,
+++		GPU:          0,
+++	},
+++	"x1e.8xlarge": {
+++		InstanceType: "x1e.8xlarge",
+++		VCPU:         32,
+++		MemoryMb:     999424,
+++		GPU:          0,
+++	},
+++	"x1e.xlarge": {
+++		InstanceType: "x1e.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     124928,
+++		GPU:          0,
+++	},
+++	"z1d": {
+++		InstanceType: "z1d",
+++		VCPU:         48,
+++		MemoryMb:     0,
+++		GPU:          0,
+++	},
+++	"z1d.12xlarge": {
+++		InstanceType: "z1d.12xlarge",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"z1d.2xlarge": {
+++		InstanceType: "z1d.2xlarge",
+++		VCPU:         8,
+++		MemoryMb:     65536,
+++		GPU:          0,
+++	},
+++	"z1d.3xlarge": {
+++		InstanceType: "z1d.3xlarge",
+++		VCPU:         12,
+++		MemoryMb:     98304,
+++		GPU:          0,
+++	},
+++	"z1d.6xlarge": {
+++		InstanceType: "z1d.6xlarge",
+++		VCPU:         24,
+++		MemoryMb:     196608,
+++		GPU:          0,
+++	},
+++	"z1d.large": {
+++		InstanceType: "z1d.large",
+++		VCPU:         2,
+++		MemoryMb:     16384,
+++		GPU:          0,
+++	},
+++	"z1d.metal": {
+++		InstanceType: "z1d.metal",
+++		VCPU:         48,
+++		MemoryMb:     393216,
+++		GPU:          0,
+++	},
+++	"z1d.xlarge": {
+++		InstanceType: "z1d.xlarge",
+++		VCPU:         4,
+++		MemoryMb:     32768,
+++		GPU:          0,
+++	},
+++}
++diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go
++new file mode 100644
++index 000000000..7644f921d
++--- /dev/null
+++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider.go
++@@ -0,0 +1,152 @@
+++/*
+++Copyright 2016 The Kubernetes Authors.
+++Licensed under the Apache License, Version 2.0 (the "License");
+++you may not use this file except in compliance with the License.
+++You may obtain a copy of the License at
+++    http://www.apache.org/licenses/LICENSE-2.0
+++Unless required by applicable law or agreed to in writing, software
+++distributed under the License is distributed on an "AS IS" BASIS,
+++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++See the License for the specific language governing permissions and
+++limitations under the License.
+++*/
+++
+++package spotinst
+++
+++import (
+++	"io"
+++	apiv1 "k8s.io/api/core/v1"
+++	"k8s.io/apimachinery/pkg/api/resource"
+++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+++	"k8s.io/autoscaler/cluster-autoscaler/config"
+++	"k8s.io/autoscaler/cluster-autoscaler/utils/errors"
+++	"k8s.io/klog"
+++	"os"
+++)
+++
+++const (
+++	ProviderName = "spotinst"
+++
+++	// GPULabel is the label added to nodes with GPU resource.
+++	GPULabel = "k8s.amazonaws.com/accelerator"
+++)
+++
+++// CloudProvider implements CloudProvider interface.
+++type CloudProvider struct {
+++	manager         *CloudManager
+++	resourceLimiter *cloudprovider.ResourceLimiter
+++}
+++
+++var (
+++	availableGPUTypes = map[string]struct{}{
+++		"nvidia-tesla-k80":  {},
+++		"nvidia-tesla-p100": {},
+++		"nvidia-tesla-v100": {},
+++	}
+++)
+++
+++// NewCloudProvider returns CloudProvider implementation for Spotinst.
+++func NewCloudProvider(manager *CloudManager, resourceLimiter *cloudprovider.ResourceLimiter) (*CloudProvider, error) {
+++	klog.Info("Building Spotinst cloud provider")
+++	cloud := &CloudProvider{
+++		manager:         manager,
+++		resourceLimiter: resourceLimiter,
+++	}
+++
+++	return cloud, nil
+++}
+++
+++// Name returns name of the cloud c.
+++func (c *CloudProvider) Name() string {
+++	return ProviderName
+++}
+++
+++// NodeGroups returns all node groups configured for this cloud c.
+++func (c *CloudProvider) NodeGroups() []cloudprovider.NodeGroup {
+++	out := make([]cloudprovider.NodeGroup, len(c.manager.groups))
+++	for i, group := range c.manager.groups {
+++		out[i] = group
+++	}
+++	return out
+++}
+++
+++// NodeGroupForNode returns the node group for the given node.
+++func (c *CloudProvider) NodeGroupForNode(node *apiv1.Node) (cloudprovider.NodeGroup, error) {
+++	instanceID, err := extractInstanceId(node.Spec.ProviderID)
+++	if err != nil {
+++		return nil, err
+++	}
+++	return c.manager.GetGroupForInstance(instanceID)
+++}
+++
+++// Pricing returns pricing model for this cloud provider or error if not available.
+++func (c *CloudProvider) Pricing() (cloudprovider.PricingModel, errors.AutoscalerError) {
+++	return nil, cloudprovider.ErrNotImplemented
+++}
+++
+++// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.
+++// Implementation optional.
+++func (c *CloudProvider) GetAvailableMachineTypes() ([]string, error) {
+++	return []string{}, nil
+++}
+++
+++// NewNodeGroup builds a theoretical node group based on the node definition provided.
+++func (c *CloudProvider) NewNodeGroup(machineType string, labels map[string]string, systemLabels map[string]string,
+++	taints []apiv1.Taint, extraResources map[string]resource.Quantity) (cloudprovider.NodeGroup, error) {
+++	return nil, cloudprovider.ErrNotImplemented
+++}
+++
+++// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).
+++func (c *CloudProvider) GetResourceLimiter() (*cloudprovider.ResourceLimiter, error) {
+++	return c.resourceLimiter, nil
+++}
+++
+++// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.
+++func (c *CloudProvider) Cleanup() error {
+++	return c.manager.Cleanup()
+++}
+++
+++// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
+++// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
+++func (c *CloudProvider) Refresh() error {
+++	return c.manager.Refresh()
+++}
+++
+++// GetInstanceID gets the instance ID for the specified node.
+++func (c *CloudProvider) GetInstanceID(node *apiv1.Node) string {
+++	return node.Spec.ProviderID
+++}
+++
+++// GPULabel returns the label added to nodes with GPU resource.
+++func (c *CloudProvider) GPULabel() string {
+++	return GPULabel
+++}
+++
+++// GetAvailableGPUTypes return all available GPU types cloud provider supports
+++func (c *CloudProvider) GetAvailableGPUTypes() map[string]struct{} {
+++	return availableGPUTypes
+++}
+++
+++func BuildSpotinst(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
+++	var config io.ReadCloser
+++	if opts.CloudConfig != "" {
+++		var err error
+++		config, err = os.Open(opts.CloudConfig)
+++		if err != nil {
+++			klog.Fatalf("Couldn't open cloud provider configuration %s: %#v", opts.CloudConfig, err)
+++		}
+++		defer config.Close()
+++	}
+++
+++	manager, err := NewCloudManager(config, do)
+++	if err != nil {
+++		klog.Fatalf("Failed to create Spotinst manager: %v", err)
+++	}
+++
+++	provider, err := NewCloudProvider(manager, rl)
+++	if err != nil {
+++		klog.Fatalf("Failed to create Spotinst cloud provider: %v", err)
+++	}
+++
+++	return provider
+++}
++diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go
++new file mode 100644
++index 000000000..28ee79069
++--- /dev/null
+++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_cloud_provider_test.go
++@@ -0,0 +1,409 @@
+++/*
+++Copyright 2016 The Kubernetes Authors.
+++Licensed under the Apache License, Version 2.0 (the "License");
+++you may not use this file except in compliance with the License.
+++You may obtain a copy of the License at
+++    http://www.apache.org/licenses/LICENSE-2.0
+++Unless required by applicable law or agreed to in writing, software
+++distributed under the License is distributed on an "AS IS" BASIS,
+++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++See the License for the specific language governing permissions and
+++limitations under the License.
+++*/
+++
+++package spotinst
+++
+++import (
+++	"context"
+++	"testing"
+++	"time"
+++
+++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
+++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/azure"
+++	azurev3 "github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/azure/v3"
+++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/gcp"
+++	"github.com/spotinst/spotinst-sdk-go/spotinst"
+++	"github.com/stretchr/testify/assert"
+++	"github.com/stretchr/testify/mock"
+++	apiv1 "k8s.io/api/core/v1"
+++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+++)
+++
+++type groupServiceMock struct {
+++	mock.Mock
+++	providerAWS *awsServiceMock
+++}
+++
+++func (s *groupServiceMock) CloudProviderAWS() aws.Service {
+++	return s.providerAWS
+++}
+++
+++func (s *groupServiceMock) CloudProviderGCP() gcp.Service {
+++	return nil // not implemented
+++}
+++
+++func (s *groupServiceMock) CloudProviderAzure() azure.Service {
+++	return nil // not implemented
+++}
+++
+++func (s *groupServiceMock) CloudProviderAzureV3() azurev3.Service {
+++	return nil // not implemented
+++}
+++
+++type awsServiceMock struct {
+++	mock.Mock
+++}
+++
+++func (s *awsServiceMock) List(ctx context.Context, input *aws.ListGroupsInput) (*aws.ListGroupsOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) Create(ctx context.Context, input *aws.CreateGroupInput) (*aws.CreateGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) DeploymentStatusECS(context.Context, *aws.DeploymentStatusInput) (*aws.RollGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) DeploymentStatus(context.Context, *aws.DeploymentStatusInput) (*aws.RollGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) RollECS(context.Context, *aws.RollECSGroupInput) (*aws.RollGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) Scale(context.Context, *aws.ScaleGroupInput) (*aws.ScaleGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) FinishBeanstalkMaintenance(context.Context, *aws.BeanstalkMaintenanceInput) (*aws.BeanstalkMaintenanceOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) GetBeanstalkMaintenanceStatus(context.Context, *aws.BeanstalkMaintenanceInput) (*string, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) GetGroupEvents(context.Context, *aws.GetGroupEventsInput) (*aws.GetGroupEventsOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) StartBeanstalkMaintenance(context.Context, *aws.BeanstalkMaintenanceInput) (*aws.BeanstalkMaintenanceOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) Read(ctx context.Context, input *aws.ReadGroupInput) (*aws.ReadGroupOutput, error) {
+++	out := &aws.ReadGroupOutput{
+++		Group: &aws.Group{
+++			Capacity: &aws.Capacity{
+++				Target: spotinst.Int(2),
+++			},
+++		},
+++	}
+++	return out, nil
+++}
+++
+++func (s *awsServiceMock) GetInstanceHealthiness(context.Context, *aws.GetInstanceHealthinessInput) (*aws.GetInstanceHealthinessOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) ImportBeanstalkEnv(context.Context, *aws.ImportBeanstalkInput) (*aws.ImportBeanstalkOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) StopDeployment(context.Context, *aws.StopDeploymentInput) (*aws.StopDeploymentOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) Update(ctx context.Context, input *aws.UpdateGroupInput) (*aws.UpdateGroupOutput, error) {
+++	args := s.Called(ctx, input)
+++	return args.Get(0).(*aws.UpdateGroupOutput), nil
+++}
+++
+++func (s *awsServiceMock) Delete(ctx context.Context, input *aws.DeleteGroupInput) (*aws.DeleteGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) Status(ctx context.Context, input *aws.StatusGroupInput) (*aws.StatusGroupOutput, error) {
+++	out := &aws.StatusGroupOutput{
+++		Instances: []*aws.Instance{
+++			{
+++				ID: spotinst.String("test-instance-id"),
+++			},
+++			{
+++				ID: spotinst.String("second-test-instance-id"),
+++			},
+++		},
+++	}
+++	return out, nil
+++}
+++
+++func (s *awsServiceMock) Detach(ctx context.Context, input *aws.DetachGroupInput) (*aws.DetachGroupOutput, error) {
+++	args := s.Called(ctx, input)
+++	return args.Get(0).(*aws.DetachGroupOutput), nil
+++}
+++
+++func (s *awsServiceMock) Roll(ctx context.Context, input *aws.RollGroupInput) (*aws.RollGroupOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) CreateSuspensions(ctx context.Context, input *aws.CreateSuspensionsInput) (*aws.CreateSuspensionsOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) ListSuspensions(context.Context, *aws.ListSuspensionsInput) (*aws.ListSuspensionsOutput, error) {
+++	return nil, nil
+++}
+++func (s *awsServiceMock) DeleteSuspensions(context.Context, *aws.DeleteSuspensionsInput) (*aws.DeleteSuspensionsOutput, error) {
+++	return nil, nil
+++}
+++
+++func (s *awsServiceMock) ListStatefulInstances(context.Context, *aws.ListStatefulInstancesInput) (*aws.ListStatefulInstancesOutput, error) {
+++	return nil, nil
+++}
+++func (s *awsServiceMock) PauseStatefulInstance(context.Context, *aws.PauseStatefulInstanceInput) (*aws.PauseStatefulInstanceOutput, error) {
+++	return nil, nil
+++}
+++func (s *awsServiceMock) ResumeStatefulInstance(context.Context, *aws.ResumeStatefulInstanceInput) (*aws.ResumeStatefulInstanceOutput, error) {
+++	return nil, nil
+++}
+++func (s *awsServiceMock) RecycleStatefulInstance(context.Context, *aws.RecycleStatefulInstanceInput) (*aws.RecycleStatefulInstanceOutput, error) {
+++	return nil, nil
+++}
+++func (s *awsServiceMock) DeallocateStatefulInstance(context.Context, *aws.DeallocateStatefulInstanceInput) (*aws.DeallocateStatefulInstanceOutput, error) {
+++	return nil, nil
+++}
+++
+++func testCloudManager(t *testing.T) *CloudManager {
+++	return &CloudManager{
+++		groupService: &groupServiceMock{
+++			providerAWS: new(awsServiceMock),
+++		},
+++		groups:          make([]*Group, 0),
+++		cache:           make(map[string]*Group),
+++		interruptCh:     make(chan struct{}),
+++		refreshInterval: time.Minute,
+++	}
+++}
+++
+++func testCloudProvider(t *testing.T, m *CloudManager) *CloudProvider {
+++	resourceLimiter := cloudprovider.NewResourceLimiter(
+++		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
+++		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
+++
+++	cloud, err := NewCloudProvider(m, resourceLimiter)
+++	assert.NoError(t, err)
+++	return cloud
+++}
+++
+++func TestNewCloudProvider(t *testing.T) {
+++	testCloudProvider(t, testCloudManager(t))
+++}
+++
+++func TestAddNodeGroup(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("bad spec")
+++	assert.Error(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 0)
+++
+++	err = provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 1)
+++}
+++
+++func TestName(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	assert.Equal(t, provider.Name(), "spotinst")
+++}
+++
+++func TestNodeGroups(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	assert.Equal(t, len(provider.NodeGroups()), 0)
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.NodeGroups()), 1)
+++}
+++
+++func TestNodeGroupForNode(t *testing.T) {
+++	node := &apiv1.Node{
+++		Spec: apiv1.NodeSpec{
+++			ProviderID: "aws:///us-east-1a/test-instance-id",
+++		},
+++	}
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	group, err := provider.NodeGroupForNode(node)
+++
+++	assert.NoError(t, err)
+++	assert.Equal(t, group.Id(), "sig-test")
+++	assert.Equal(t, group.MinSize(), 1)
+++	assert.Equal(t, group.MaxSize(), 5)
+++
+++	// test node in cluster that is not in a group managed by cluster autoscaler
+++	nodeNotInGroup := &apiv1.Node{
+++		Spec: apiv1.NodeSpec{
+++			ProviderID: "aws:///us-east-1a/test-instance-id-not-in-group",
+++		},
+++	}
+++
+++	group, err = provider.NodeGroupForNode(nodeNotInGroup)
+++	assert.NoError(t, err)
+++	assert.Nil(t, group)
+++}
+++
+++func TestExtractInstanceId(t *testing.T) {
+++	_, err := extractInstanceId("bad spec")
+++	assert.Error(t, err)
+++
+++	instanceID, err := extractInstanceId("aws:///us-east-1a/i-260942b3")
+++	assert.NoError(t, err)
+++	assert.Equal(t, instanceID, "i-260942b3")
+++}
+++
+++func TestMaxSize(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 1)
+++	assert.Equal(t, provider.manager.groups[0].MaxSize(), 5)
+++}
+++
+++func TestMinSize(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 1)
+++	assert.Equal(t, provider.manager.groups[0].MinSize(), 1)
+++}
+++
+++func TestTargetSize(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	targetSize, err := provider.manager.groups[0].TargetSize()
+++	assert.Equal(t, targetSize, 2)
+++	assert.NoError(t, err)
+++}
+++
+++func TestIncreaseSize(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 1)
+++
+++	cloud := provider.manager.groupService.CloudProviderAWS().(*awsServiceMock)
+++	cloud.On("Update", context.Background(), &aws.UpdateGroupInput{
+++		Group: &aws.Group{
+++			ID: spotinst.String(provider.manager.groups[0].Id()),
+++			Capacity: &aws.Capacity{
+++				Target:  spotinst.Int(3),
+++				Minimum: spotinst.Int(provider.manager.groups[0].minSize),
+++				Maximum: spotinst.Int(provider.manager.groups[0].maxSize),
+++			},
+++		},
+++	}).Return(&aws.UpdateGroupOutput{})
+++
+++	err = provider.manager.groups[0].IncreaseSize(1)
+++	assert.NoError(t, err)
+++	cloud.AssertExpectations(t)
+++}
+++
+++func TestBelongs(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++
+++	invalidNode := &apiv1.Node{
+++		Spec: apiv1.NodeSpec{
+++			ProviderID: "aws:///us-east-1a/invalid-instance-id",
+++		},
+++	}
+++	_, err = provider.manager.groups[0].Belongs(invalidNode)
+++	assert.Error(t, err)
+++
+++	validNode := &apiv1.Node{
+++		Spec: apiv1.NodeSpec{
+++			ProviderID: "aws:///us-east-1a/test-instance-id",
+++		},
+++	}
+++	belongs, err := provider.manager.groups[0].Belongs(validNode)
+++	assert.Equal(t, belongs, true)
+++	assert.NoError(t, err)
+++}
+++
+++func TestDeleteNodes(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 1)
+++
+++	cloud := provider.manager.groupService.CloudProviderAWS().(*awsServiceMock)
+++	cloud.On("Detach", context.Background(), &aws.DetachGroupInput{
+++		GroupID:                       spotinst.String(provider.manager.groups[0].Id()),
+++		InstanceIDs:                   []string{"test-instance-id"},
+++		ShouldDecrementTargetCapacity: spotinst.Bool(true),
+++		ShouldTerminateInstances:      spotinst.Bool(true),
+++	}).Return(&aws.DetachGroupOutput{})
+++
+++	node := &apiv1.Node{
+++		Spec: apiv1.NodeSpec{
+++			ProviderID: "aws:///us-east-1a/test-instance-id",
+++		},
+++	}
+++
+++	err = provider.manager.groups[0].DeleteNodes([]*apiv1.Node{node})
+++	assert.NoError(t, err)
+++	cloud.AssertExpectations(t)
+++}
+++
+++func TestId(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.manager.addNodeGroup("1:5:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, len(provider.manager.groups), 1)
+++	assert.Equal(t, provider.manager.groups[0].Id(), "sig-test")
+++}
+++
+++func TestDebug(t *testing.T) {
+++	grp := Group{
+++		manager: testCloudManager(t),
+++		minSize: 5,
+++		maxSize: 55,
+++	}
+++	grp.groupID = "sig-test"
+++	assert.Equal(t, grp.Debug(), "sig-test (5:55)")
+++}
+++
+++func TestBuildGroup(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++
+++	_, err := provider.manager.buildGroupFromSpec("a")
+++	assert.Error(t, err)
+++	_, err = provider.manager.buildGroupFromSpec("a:b:c")
+++	assert.Error(t, err)
+++	_, err = provider.manager.buildGroupFromSpec("1:")
+++	assert.Error(t, err)
+++	_, err = provider.manager.buildGroupFromSpec("1:2:")
+++	assert.Error(t, err)
+++
+++	grp, err := provider.manager.buildGroupFromSpec("111:222:sig-test")
+++	assert.NoError(t, err)
+++	assert.Equal(t, 111, grp.MinSize())
+++	assert.Equal(t, 222, grp.MaxSize())
+++	assert.Equal(t, "sig-test", grp.Id())
+++}
+++
+++func TestGetResourceLimiter(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	_, err := provider.GetResourceLimiter()
+++	assert.NoError(t, err)
+++}
+++
+++func TestCleanup(t *testing.T) {
+++	provider := testCloudProvider(t, testCloudManager(t))
+++	err := provider.Cleanup()
+++	assert.NoError(t, err)
+++}
++diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go
++new file mode 100644
++index 000000000..9f1ed24e9
++--- /dev/null
+++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_manager.go
++@@ -0,0 +1,510 @@
+++/*
+++Copyright 2016 The Kubernetes Authors.
+++Licensed under the Apache License, Version 2.0 (the "License");
+++you may not use this file except in compliance with the License.
+++You may obtain a copy of the License at
+++    http://www.apache.org/licenses/LICENSE-2.0
+++Unless required by applicable law or agreed to in writing, software
+++distributed under the License is distributed on an "AS IS" BASIS,
+++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++See the License for the specific language governing permissions and
+++limitations under the License.
+++*/
+++
+++package spotinst
+++
+++import (
+++	"context"
+++	"errors"
+++	"fmt"
+++	"io"
+++	"k8s.io/autoscaler/cluster-autoscaler/utils/gpu"
+++	"k8s.io/klog"
+++	"math/rand"
+++	"strconv"
+++	"strings"
+++	"sync"
+++	"time"
+++
+++	"k8s.io/autoscaler/cluster-autoscaler/utils/mpscontext"
+++
+++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup"
+++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
+++	"github.com/spotinst/spotinst-sdk-go/spotinst"
+++	"github.com/spotinst/spotinst-sdk-go/spotinst/log"
+++	"github.com/spotinst/spotinst-sdk-go/spotinst/session"
+++	"github.com/spotinst/spotinst-sdk-go/spotinst/util/stringutil"
+++	apiv1 "k8s.io/api/core/v1"
+++	"k8s.io/apimachinery/pkg/api/resource"
+++	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+++	"k8s.io/apimachinery/pkg/util/wait"
+++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+++	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
+++	"k8s.io/autoscaler/cluster-autoscaler/utils/gpumemory"
+++	kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
+++	gcfg "gopkg.in/gcfg.v1"
+++)
+++
+++// CloudManager holds the config and client.
+++type CloudManager struct {
+++	groupService    elastigroup.Service
+++	groups          []*Group
+++	refreshedAt     time.Time
+++	refreshInterval time.Duration
+++	interruptCh     chan struct{}
+++	cacheMu         sync.Mutex
+++	cache           map[string]*Group // k: InstanceID, v: Group
+++}
+++
+++// CloudConfig holds the configuration parsed from the --cloud-config flag.
+++// All fields are required unless otherwise specified.
+++type CloudConfig struct {
+++	Global struct{}
+++}
+++
+++// NewCloudManager constructs manager object.
+++func NewCloudManager(config io.Reader, discoveryOpts cloudprovider.NodeGroupDiscoveryOptions) (*CloudManager, error) {
+++	klog.Info("Building Spotinst cloud manager")
+++
+++	cfg, err := readCloudConfig(config)
+++	if err != nil {
+++		return nil, err
+++	}
+++
+++	svc, err := newService(cfg)
+++	if err != nil {
+++		return nil, err
+++	}
+++
+++	manager := &CloudManager{
+++		groupService:    svc,
+++		refreshInterval: time.Minute,
+++		interruptCh:     make(chan struct{}),
+++		groups:          make([]*Group, 0),
+++		cache:           make(map[string]*Group),
+++	}
+++
+++	if err := manager.addNodeGroups(discoveryOpts.NodeGroupSpecs); err != nil {
+++		return nil, err
+++	}
+++
+++	go wait.Until(func() {
+++		manager.cacheMu.Lock()
+++		defer manager.cacheMu.Unlock()
+++
+++		if err := manager.forceRefresh(); err != nil {
+++			klog.Errorf("Error while refreshing cache: %v", err)
+++		}
+++	}, time.Hour, manager.interruptCh)
+++
+++	return manager, nil
+++}
+++
+++// newService returns a new instance of Spotinst Service.
+++func newService(cloudConfig *CloudConfig) (elastigroup.Service, error) {
+++	// Create a new config.
+++	config := spotinst.DefaultConfig()
+++	config.WithLogger(newStdLogger())
+++	config.WithUserAgent("Kubernetes-ClusterAutoscaler")
+++
+++	// Create a new session.
+++	sess := session.New(config)
+++
+++	// Create a new service.
+++	svc := elastigroup.New(sess)
+++
+++	return svc, nil
+++}
+++
+++func newStdLogger() log.Logger {
+++	return log.LoggerFunc(func(format string, args ...interface{}) {
+++		klog.V(4).Infof(format, args...)
+++	})
+++}
+++
+++// readCloudConfig reads an instance of Config from config reader.
+++func readCloudConfig(config io.Reader) (*CloudConfig, error) {
+++	var cfg CloudConfig
+++
+++	if config != nil {
+++		if err := gcfg.ReadInto(&cfg, config); err != nil {
+++			return nil, fmt.Errorf("couldn't read Spotinst config: %v", err)
+++		}
+++	}
+++
+++	return &cfg, nil
+++}
+++
+++func (mgr *CloudManager) addNodeGroups(specs []string) error {
+++	klog.Info("Attempting to add node groups")
+++
+++	for _, spec := range specs {
+++		if err := mgr.addNodeGroup(spec); err != nil {
+++			return fmt.Errorf("could not register group with spec %s: %v", spec, err)
+++		}
+++	}
+++
+++	return nil
+++}
+++
+++func (mgr *CloudManager) addNodeGroup(spec string) error {
+++	klog.Infof("Attempting to add node group: %s", spec)
+++
+++	group, err := mgr.buildGroupFromSpec(spec)
+++	if err != nil {
+++		return fmt.Errorf("could not parse spec for node group: %v", err)
+++	}
+++	err = mgr.RegisterGroup(group)
+++	if err != nil {
+++		return fmt.Errorf("could not register the group(%s): %v", group.Id(), err)
+++	}
+++
+++	klog.Infof("Node group added: %s", group.groupID)
+++	return nil
+++}
+++
+++func (mgr *CloudManager) buildGroupFromSpec(value string) (*Group, error) {
+++	spec, err := dynamic.SpecFromString(value, true)
+++	if err != nil {
+++		return nil, fmt.Errorf("failed to parse node group spec: %v", err)
+++	}
+++	group := &Group{
+++		manager: mgr,
+++		groupID: spec.Name,
+++		minSize: spec.MinSize,
+++		maxSize: spec.MaxSize,
+++	}
+++	return group, nil
+++}
+++
+++// RegisterGroup registers a resource group in Spotinst Manager.
+++func (mgr *CloudManager) RegisterGroup(grp *Group) error {
+++	mgr.cacheMu.Lock()
+++	defer mgr.cacheMu.Unlock()
+++
+++	group, err := mgr.getResourceForGroup(grp.Id())
+++	if err != nil {
+++		return err
+++	}
+++	grp.group = group
+++
+++	mgr.groups = append(mgr.groups, grp)
+++	return nil
+++}
+++
+++// GetGroupSize gets the current size of the group.
+++func (mgr *CloudManager) GetGroupSize(grp *Group) (int64, error) {
+++	group, err := mgr.getResourceForGroup(grp.Id())
+++	if err != nil {
+++		return -1, err
+++	}
+++	size := spotinst.IntValue(group.Capacity.Target)
+++	return int64(size), nil
+++}
+++
+++// SetGroupSize sets the instances count in a Group by updating a
+++// predefined Spotinst stack parameter (specified by the user).
+++func (mgr *CloudManager) SetGroupSize(grp *Group, size int64) error {
+++	in := &aws.UpdateGroupInput{
+++		Group: &aws.Group{
+++			ID: spotinst.String(grp.Id()),
+++			Capacity: &aws.Capacity{
+++				Target:  spotinst.Int(int(size)),
+++				Minimum: spotinst.Int(grp.minSize),
+++				Maximum: spotinst.Int(grp.maxSize),
+++			},
+++		},
+++	}
+++	_, err := mgr.groupService.CloudProviderAWS().Update(context.Background(), in)
+++	if err != nil {
+++		return err
+++	}
+++	return nil
+++}
+++
+++// GetGroupForInstance retrieves the resource group that contains
+++// a given instance.
+++func (mgr *CloudManager) GetGroupForInstance(instanceID string) (*Group, error) {
+++	mgr.cacheMu.Lock()
+++	defer mgr.cacheMu.Unlock()
+++
+++	if group, ok := mgr.cache[instanceID]; ok {
+++		return group, nil
+++	}
+++
+++	if err := mgr.forceRefresh(); err != nil {
+++		return nil, err
+++	}
+++
+++	if group, ok := mgr.cache[instanceID]; ok {
+++		return group, nil
+++	}
+++
+++	klog.Warningf("Instance `%s` does not belong to any managed group", instanceID)
+++	return nil, nil
+++}
+++
+++// DeleteInstances deletes the specified instances from the
+++// OpenStack resource group
+++func (mgr *CloudManager) DeleteInstances(instanceIDs []string) error {
+++	if len(instanceIDs) == 0 {
+++		return nil
+++	}
+++	commonGroup, err := mgr.GetGroupForInstance(instanceIDs[0])
+++	if err != nil {
+++		return err
+++	}
+++	for _, instanceID := range instanceIDs {
+++		instanceGroup, err := mgr.GetGroupForInstance(instanceID)
+++		if err != nil {
+++			return err
+++		}
+++		if instanceGroup.groupID != commonGroup.groupID {
+++			return errors.New("connot delete instances which don't belong to the same group")
+++		}
+++	}
+++	in := &aws.DetachGroupInput{
+++		GroupID:                       spotinst.String(commonGroup.groupID),
+++		InstanceIDs:                   instanceIDs,
+++		ShouldDecrementTargetCapacity: spotinst.Bool(true),
+++		ShouldTerminateInstances:      spotinst.Bool(true),
+++	}
+++	if _, err := mgr.groupService.CloudProviderAWS().Detach(context.Background(), in); err != nil {
+++		return fmt.Errorf("failed to detach instances from group %s: %v", commonGroup.groupID, err)
+++	}
+++	return nil
+++}
+++
+++func (mgr *CloudManager) getResourceForGroup(groupID string) (*aws.Group, error) {
+++	in := &aws.ReadGroupInput{
+++		GroupID: spotinst.String(groupID),
+++	}
+++	out, err := mgr.groupService.CloudProviderAWS().Read(context.Background(), in)
+++	if err != nil {
+++		return nil, err
+++	}
+++	if out.Group == nil {
+++		return nil, fmt.Errorf("failed to get group %s", groupID)
+++	}
+++	return out.Group, nil
+++}
+++
+++// Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc.
+++func (mgr *CloudManager) Cleanup() error {
+++	close(mgr.interruptCh)
+++	return nil
+++}
+++
+++// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
+++// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
+++func (mgr *CloudManager) Refresh() error {
+++	mgr.cacheMu.Lock()
+++	defer mgr.cacheMu.Unlock()
+++
+++	if mgr.refreshedAt.Add(mgr.refreshInterval).After(time.Now()) {
+++		return nil
+++	}
+++	return mgr.forceRefresh()
+++}
+++
+++func (mgr *CloudManager) forceRefresh() error {
+++	mgr.regenerateCache()
+++	mgr.refreshedAt = time.Now()
+++	klog.V(2).Infof("Refreshed, next refresh after %v", mgr.refreshedAt.Add(mgr.refreshInterval))
+++	return nil
+++}
+++
+++func (mgr *CloudManager) regenerateCache() {
+++	mgr.cache = make(map[string]*Group)
+++	for _, group := range mgr.groups {
+++		klog.V(4).Infof("Regenerating resource group information for %s", group.groupID)
+++		if err := mgr.refreshGroupNodes(group); err != nil {
+++			klog.Warningf("Could not retrieve nodes for group %s: %v", group.groupID, err)
+++		}
+++	}
+++}
+++
+++func (mgr *CloudManager) refreshGroupNodes(grp *Group) error {
+++	in := &aws.StatusGroupInput{
+++		GroupID: spotinst.String(grp.Id()),
+++	}
+++	status, err := mgr.groupService.CloudProviderAWS().Status(context.Background(), in)
+++	if err != nil {
+++		return err
+++	}
+++	for _, instance := range status.Instances {
+++		if instance.ID != nil {
+++			instanceID := spotinst.StringValue(instance.ID)
+++			klog.Infof("Managing AWS instance with ID %s in group %s", instanceID, grp.Id())
+++			mgr.cache[instanceID] = grp
+++		}
+++	}
+++	return nil
+++}
+++
+++type groupTemplate struct {
+++	InstanceType *instanceType
+++	Region       string
+++	Zone         string
+++	Tags         []*aws.Tag
+++}
+++
+++func (mgr *CloudManager) inferInstanceType(instanceTypeName string) *instanceType {
+++	ret := &instanceType{
+++		InstanceType: instanceTypeName,
+++		VCPU:         1,
+++		MemoryMb:     1024, // 1GB
+++		GPU:          0,
+++	}
+++	size := 1
+++	if strings.HasSuffix(instanceTypeName, ".medium") || strings.HasSuffix(instanceTypeName, ".large") {
+++		size = 1
+++	} else if strings.HasSuffix(instanceTypeName, ".xlarge") {
+++		size = 2
+++	} else {
+++		elems := strings.Split(instanceTypeName, ".")
+++		if len(elems) > 1 {
+++			nums := strings.Split(elems[1], "xlarge")
+++			if len(nums) > 0 {
+++				if num, err := strconv.Atoi(nums[0]); err == nil {
+++					size = num * 2
+++				}
+++			}
+++		}
+++	}
+++	ret.VCPU = 2 * int64(size)
+++	ret.MemoryMb = 1024 * 2 * ret.VCPU
+++	if strings.HasPrefix(instanceTypeName, "g") || strings.HasPrefix(instanceTypeName, "p") {
+++		ret.GPU = int64(size / 4)
+++		if ret.GPU <= 0 {
+++			ret.GPU = 1
+++		}
+++	}
+++	return ret
+++}
+++
+++func (mgr *CloudManager) buildGroupTemplate(groupID string) (*groupTemplate, error) {
+++	klog.Infof("Building template for group %s", groupID)
+++
+++	group, err := mgr.getResourceForGroup(groupID)
+++	if err != nil {
+++		return nil, err
+++	}
+++
+++	if len(group.Compute.AvailabilityZones) < 1 {
+++		return nil, fmt.Errorf("unable to get first AvailabilityZone for %s", groupID)
+++	}
+++
+++	zone := spotinst.StringValue(group.Compute.AvailabilityZones[0].Name)
+++	region := zone[0 : len(zone)-1]
+++
+++	if len(group.Compute.AvailabilityZones) > 1 {
+++		klog.Warningf("Found multiple availability zones, using %s", zone)
+++	}
+++
+++	instanceTypeName := spotinst.StringValue(group.Compute.InstanceTypes.OnDemand)
+++	foundInstanceType := InstanceTypes[instanceTypeName]
+++	if foundInstanceType == nil {
+++		klog.Warningf("Unable to get node template info for instance type %s", instanceTypeName)
+++		foundInstanceType = mgr.inferInstanceType(instanceTypeName)
+++	}
+++
+++	tmpl := &groupTemplate{
+++		InstanceType: foundInstanceType,
+++		Region:       region,
+++		Zone:         zone,
+++		Tags:         group.Compute.LaunchSpecification.Tags,
+++	}
+++
+++	return tmpl, nil
+++}
+++
+++func (mgr *CloudManager) buildNodeFromTemplate(group *Group, template *groupTemplate) (*apiv1.Node, error) {
+++	klog.Infof("Building node from template of group %s", group.Id())
+++
+++	node := apiv1.Node{}
+++	nodeName := fmt.Sprintf("%s-group-%d", group.groupID, rand.Int63())
+++
+++	node.ObjectMeta = metav1.ObjectMeta{
+++		Name:     nodeName,
+++		SelfLink: fmt.Sprintf("/api/v1/nodes/%s", nodeName),
+++		Labels:   map[string]string{},
+++	}
+++
+++	node.Status = apiv1.NodeStatus{
+++		Capacity: apiv1.ResourceList{},
+++	}
+++
+++	node.Status.Capacity[apiv1.ResourcePods] = *resource.NewQuantity(110, resource.DecimalSI)
+++	node.Status.Capacity[apiv1.ResourceCPU] = *resource.NewQuantity(template.InstanceType.VCPU, resource.DecimalSI)
+++	node.Status.Capacity[apiv1.ResourceMemory] = *resource.NewQuantity(template.InstanceType.MemoryMb*1024*1024, resource.DecimalSI)
+++	node.Status.Capacity[gpu.ResourceNvidiaGPU] = *resource.NewQuantity(template.InstanceType.GPU, resource.DecimalSI)
+++	node.Status.Capacity[gpumemory.ResourceVisenzeGPUMemory] = *resource.NewQuantity(template.InstanceType.GPUMemory, resource.DecimalSI)
+++	node.Status.Capacity[mpscontext.ResourceVisenzeMPSContext] = *resource.NewQuantity(template.InstanceType.MPSContext, resource.DecimalSI)
+++	node.Status.Allocatable = node.Status.Capacity
+++
+++	// NodeLabels
+++	node.Labels = cloudprovider.JoinStringMaps(node.Labels, extractLabelsFromGroup(template.Tags))
+++
+++	// GenericLabels
+++	node.Labels = cloudprovider.JoinStringMaps(node.Labels, buildGenericLabels(template, nodeName))
+++
+++	node.Spec.Taints = extractTaintsFromGroup(template.Tags)
+++	node.Status.Conditions = cloudprovider.BuildReadyConditions()
+++
+++	klog.V(4).Infof("Node `%s` labels: %s", nodeName, stringutil.Stringify(node.Labels))
+++	klog.V(4).Infof("Node `%s` taints: %s", nodeName, stringutil.Stringify(node.Spec.Taints))
+++
+++	return &node, nil
+++}
+++
+++func buildGenericLabels(template *groupTemplate, nodeName string) map[string]string {
+++	result := make(map[string]string)
+++
+++	result[kubeletapis.LabelArch] = cloudprovider.DefaultArch
+++	result[kubeletapis.LabelOS] = cloudprovider.DefaultOS
+++	result[apiv1.LabelInstanceType] = template.InstanceType.InstanceType
+++	result[apiv1.LabelZoneRegion] = template.Region
+++	result[apiv1.LabelZoneFailureDomain] = template.Zone
+++	result[apiv1.LabelHostname] = nodeName
+++
+++	return result
+++}
+++
+++func extractLabelsFromGroup(tags []*aws.Tag) map[string]string {
+++	result := make(map[string]string)
+++
+++	for _, tag := range tags {
+++		k := *tag.Key
+++		v := *tag.Value
+++		splits := strings.Split(k, "k8s.io/cluster-autoscaler/node-template/label/")
+++		if len(splits) > 1 {
+++			label := splits[1]
+++			if label != "" {
+++				result[label] = v
+++			}
+++		}
+++	}
+++
+++	return result
+++}
+++
+++func extractTaintsFromGroup(tags []*aws.Tag) []apiv1.Taint {
+++	taints := make([]apiv1.Taint, 0)
+++
+++	for _, tag := range tags {
+++		k := *tag.Key
+++		v := *tag.Value
+++		splits := strings.Split(k, "k8s.io/cluster-autoscaler/node-template/taint/")
+++		if len(splits) > 1 {
+++			values := strings.SplitN(v, ":", 2)
+++			taints = append(taints, apiv1.Taint{
+++				Key:    splits[1],
+++				Value:  values[0],
+++				Effect: apiv1.TaintEffect(values[1]),
+++			})
+++		}
+++	}
+++
+++	return taints
+++}
++diff --git a/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go b/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go
++new file mode 100644
++index 000000000..648a559ad
++--- /dev/null
+++++ b/cluster-autoscaler/cloudprovider/spotinst/spotinst_node_group.go
++@@ -0,0 +1,225 @@
+++/*
+++Copyright 2016 The Kubernetes Authors.
+++Licensed under the Apache License, Version 2.0 (the "License");
+++you may not use this file except in compliance with the License.
+++You may obtain a copy of the License at
+++    http://www.apache.org/licenses/LICENSE-2.0
+++Unless required by applicable law or agreed to in writing, software
+++distributed under the License is distributed on an "AS IS" BASIS,
+++WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++See the License for the specific language governing permissions and
+++limitations under the License.
+++*/
+++
+++package spotinst
+++
+++import (
+++	"context"
+++	"errors"
+++	"fmt"
+++	"k8s.io/klog"
+++	"regexp"
+++	"strings"
+++
+++	"github.com/spotinst/spotinst-sdk-go/service/elastigroup/providers/aws"
+++	"github.com/spotinst/spotinst-sdk-go/spotinst"
+++	apiv1 "k8s.io/api/core/v1"
+++	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
+++	"k8s.io/kubernetes/pkg/scheduler/nodeinfo"
+++)
+++
+++type Group struct {
+++	manager *CloudManager
+++	group   *aws.Group
+++	groupID string
+++	minSize int
+++	maxSize int
+++}
+++
+++// MaxSize returns maximum size of the node group.
+++func (grp *Group) MaxSize() int {
+++	return grp.maxSize
+++}
+++
+++// MinSize returns minimum size of the node group.
+++func (grp *Group) MinSize() int {
+++	return grp.minSize
+++}
+++
+++// TargetSize returns the current target size of the node group.
+++func (grp *Group) TargetSize() (int, error) {
+++	size, err := grp.manager.GetGroupSize(grp)
+++	return int(size), err
+++}
+++
+++// IncreaseSize increases the size of the node group.
+++func (grp *Group) IncreaseSize(delta int) error {
+++	if delta <= 0 {
+++		return errors.New("size increase must be positive")
+++	}
+++	size, err := grp.manager.GetGroupSize(grp)
+++	if err != nil {
+++		return err
+++	}
+++	if int(size)+delta > grp.MaxSize() {
+++		return fmt.Errorf("size increase too large - desired:%d max:%d", int(size)+delta, grp.MaxSize())
+++	}
+++	return grp.manager.SetGroupSize(grp, size+int64(delta))
+++}
+++
+++// DeleteNodes deletes nodes from this node group.
+++func (grp *Group) DeleteNodes(nodes []*apiv1.Node) error {
+++	size, err := grp.manager.GetGroupSize(grp)
+++	if err != nil {
+++		return fmt.Errorf("error when deleting nodes, retrieving size of group %s failed: %v", grp.Id(), err)
+++	}
+++	if int(size) <= grp.MinSize() {
+++		return errors.New("min size reached, nodes will not be deleted")
+++	}
+++	toBeDeleted := make([]string, 0)
+++	for _, node := range nodes {
+++		belongs, err := grp.Belongs(node)
+++		if err != nil {
+++			return fmt.Errorf("failed to check membership of node %s in group %s: %v", node.Name, grp.Id(), err)
+++		}
+++		if !belongs {
+++			return fmt.Errorf("%s belongs to a different group than %s", node.Name, grp.Id())
+++		}
+++		instanceID, err := extractInstanceId(node.Spec.ProviderID)
+++		if err != nil {
+++			return fmt.Errorf("node %s's cloud provider ID is malformed: %v", node.Name, err)
+++		}
+++		toBeDeleted = append(toBeDeleted, instanceID)
+++	}
+++	return grp.manager.DeleteInstances(toBeDeleted)
+++}
+++
+++// DecreaseTargetSize decreases the target size of the node group.
+++func (grp *Group) DecreaseTargetSize(delta int) error {
+++	if delta >= 0 {
+++		return errors.New("size decrease size must be negative")
+++	}
+++	size, err := grp.manager.GetGroupSize(grp)
+++	if err != nil {
+++		return err
+++	}
+++	nodes, err := grp.Nodes()
+++	if err != nil {
+++		return err
+++	}
+++	if int(size)+delta < len(nodes) {
+++		return fmt.Errorf("size decrease too large - desired:%d existing:%d", int(size)+delta, len(nodes))
+++	}
+++	return grp.manager.SetGroupSize(grp, size+int64(delta))
+++}
+++
+++// Id returns an unique identifier of the node group.
+++func (grp *Group) Id() string {
+++	return grp.groupID
+++}
+++
+++// Debug returns a string containing all information regarding this node group.
+++func (grp *Group) Debug() string {
+++	return fmt.Sprintf("%s (%d:%d)", grp.Id(), grp.MinSize(), grp.MaxSize())
+++}
+++
+++// Nodes returns a list of all nodes that belong to this node group.
+++func (grp *Group) Nodes() ([]cloudprovider.Instance, error) {
+++	in := &aws.StatusGroupInput{
+++		GroupID: spotinst.String(grp.Id()),
+++	}
+++	status, err := grp.manager.groupService.CloudProviderAWS().Status(context.Background(), in)
+++	if err != nil {
+++		return []cloudprovider.Instance{}, err
+++	}
+++	out := make([]cloudprovider.Instance, 0)
+++	for _, instance := range status.Instances {
+++		if instance.ID != nil && instance.AvailabilityZone != nil {
+++			out = append(out, cloudprovider.Instance{Id: fmt.Sprintf("aws:///%s/%s", *instance.AvailabilityZone, *instance.ID)})
+++		}
+++	}
+++	return out, nil
+++}
+++
+++// TemplateNodeInfo returns a node template for this node group.
+++func (grp *Group) TemplateNodeInfo() (*nodeinfo.NodeInfo, error) {
+++	klog.Infof("No working nodes in node group %s, trying to generate from template", grp.Id())
+++
+++	template, err := grp.manager.buildGroupTemplate(grp.Id())
+++	if err != nil {
+++		return nil, err
+++	}
+++
+++	node, err := grp.manager.buildNodeFromTemplate(grp, template)
+++	if err != nil {
+++		return nil, err
+++	}
+++
+++	nodeInfo := nodeinfo.NewNodeInfo(cloudprovider.BuildKubeProxy(grp.Id()))
+++	nodeInfo.SetNode(node)
+++	return nodeInfo, nil
+++}
+++
+++// Belongs returns true if the given node belongs to the NodeGroup.
+++func (grp *Group) Belongs(node *apiv1.Node) (bool, error) {
+++	instanceID, err := extractInstanceId(node.Spec.ProviderID)
+++	if err != nil {
+++		return false, err
+++	}
+++	group, err := grp.manager.GetGroupForInstance(instanceID)
+++	if err != nil {
+++		return false, err
+++	}
+++	if group == nil {
+++		return false, fmt.Errorf("%s does not belong to a known group", node.Name)
+++	}
+++	return true, nil
+++}
+++
+++// Exist checks if the node group really exists on the cloud provider side.
+++func (grp *Group) Exist() bool {
+++	return true
+++}
+++
+++// Create creates the node group on the cloud provider side.
+++func (grp *Group) Create() (cloudprovider.NodeGroup, error) {
+++	return nil, cloudprovider.ErrAlreadyExist
+++}
+++
+++// Delete deletes the node group on the cloud provider side.
+++func (grp *Group) Delete() error {
+++	return cloudprovider.ErrNotImplemented
+++}
+++
+++// Autoprovisioned returns true if the node group is autoprovisioned.
+++func (grp *Group) Autoprovisioned() bool {
+++	return false
+++}
+++
+++var (
+++	spotinstProviderRE = regexp.MustCompile(`^spotinst\:\/\/\/[-0-9a-z]*\/[-0-9a-z]*$`)
+++	awsProviderRE      = regexp.MustCompile(`^aws\:\/\/\/[-0-9a-z]*\/[-0-9a-z]*$`)
+++)
+++
+++func extractInstanceId(providerID string) (string, error) {
+++	var prefix string
+++
+++	if spotinstProviderRE.FindStringSubmatch(providerID) != nil {
+++		prefix = "spotinst:///"
+++	}
+++
+++	if awsProviderRE.FindStringSubmatch(providerID) != nil {
+++		prefix = "aws:///"
+++	}
+++
+++	if prefix == "" {
+++		return "", fmt.Errorf("expected node provider ID to be one of the "+
+++			"forms `spotinst:///<zone>/<instance-id>` or `aws:///<zone>/<instance-id>`, got `%s`", providerID)
+++	}
+++
+++	parts := strings.Split(providerID[len(prefix):], "/")
+++	instanceID := parts[1]
+++
+++	klog.Infof("Instance ID `%s` extracted from provider `%s`", instanceID, providerID)
+++	return instanceID, nil
+++}
++diff --git a/cluster-autoscaler/utils/gpumemory/gpumemory.go b/cluster-autoscaler/utils/gpumemory/gpumemory.go
++new file mode 100644
++index 000000000..74dad4198
++--- /dev/null
+++++ b/cluster-autoscaler/utils/gpumemory/gpumemory.go
++@@ -0,0 +1,41 @@
+++package gpumemory
+++
+++import (
+++	apiv1 "k8s.io/api/core/v1"
+++	"k8s.io/apimachinery/pkg/api/resource"
+++)
+++
+++const (
+++	// ResourceVisenzeGPUMemory is the name of the GPU Memory resource
+++	ResourceVisenzeGPUMemory = "visenze.com/nvidia-gpu-memory"
+++	// GPULabel is the label added to nodes with GPU resource by Visenze.
+++	// If you're not scaling - this is probably the problem!
+++	GPULabel = "accelerator"
+++)
+++
+++// NodeHasGpuMemory returns true if a given node has GPU hardware
+++func NodeHasGpuMemory(node *apiv1.Node) bool {
+++	_, hasGpuLabel := node.Labels[GPULabel]
+++	gpuAllocatable, hasGpuAllocatable := node.Status.Allocatable[ResourceVisenzeGPUMemory]
+++	return hasGpuLabel || (hasGpuAllocatable && !gpuAllocatable.IsZero())
+++}
+++
+++// PodRequestsGpuMemory returns true if a given pod has GPU Memory request
+++func PodRequestsGpuMemory(pod *apiv1.Pod) bool {
+++	for _, container := range pod.Spec.Containers {
+++		if container.Resources.Requests != nil {
+++			_, gpuMemoryFound := container.Resources.Requests[ResourceVisenzeGPUMemory]
+++			if gpuMemoryFound {
+++				return true
+++			}
+++		}
+++	}
+++	return false
+++}
+++
+++// RequestInfo gives some information about hwo much GPU memory is needed
+++type RequestInfo struct {
+++	MaximumMemory resource.Quantity
+++	TotalMemory   resource.Quantity
+++	Pods          []*apiv1.Pod
+++}
++diff --git a/cluster-autoscaler/utils/gpumemory/gpumemory_test.go b/cluster-autoscaler/utils/gpumemory/gpumemory_test.go
++new file mode 100644
++index 000000000..a69db0687
++--- /dev/null
+++++ b/cluster-autoscaler/utils/gpumemory/gpumemory_test.go
++@@ -0,0 +1,83 @@
+++package gpumemory
+++
+++import (
+++	"testing"
+++
+++	"github.com/stretchr/testify/assert"
+++	apiv1 "k8s.io/api/core/v1"
+++	"k8s.io/apimachinery/pkg/api/resource"
+++	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+++)
+++
+++func TestNodeHasGpuMemory(t *testing.T) {
+++	gpuLabels := map[string]string{
+++		GPULabel: "nvidia-tesla-k80",
+++	}
+++	nodeGpuReady := &apiv1.Node{
+++		ObjectMeta: metav1.ObjectMeta{
+++			Name:   "nodeGpuReady",
+++			Labels: gpuLabels,
+++		},
+++		Status: apiv1.NodeStatus{
+++			Capacity:    apiv1.ResourceList{},
+++			Allocatable: apiv1.ResourceList{},
+++		},
+++	}
+++	nodeGpuReady.Status.Allocatable[ResourceVisenzeGPUMemory] = *resource.NewQuantity(8e9, resource.DecimalSI)
+++	nodeGpuReady.Status.Capacity[ResourceVisenzeGPUMemory] = *resource.NewQuantity(8e9, resource.DecimalSI)
+++	assert.True(t, NodeHasGpuMemory(nodeGpuReady))
+++
+++	nodeGpuUnready := &apiv1.Node{
+++		ObjectMeta: metav1.ObjectMeta{
+++			Name:   "nodeGpuUnready",
+++			Labels: gpuLabels,
+++		},
+++		Status: apiv1.NodeStatus{
+++			Capacity:    apiv1.ResourceList{},
+++			Allocatable: apiv1.ResourceList{},
+++		},
+++	}
+++	assert.True(t, NodeHasGpuMemory(nodeGpuUnready))
+++
+++	nodeNoGpu := &apiv1.Node{
+++		ObjectMeta: metav1.ObjectMeta{
+++			Name:   "nodeNoGpu",
+++			Labels: map[string]string{},
+++		},
+++		Status: apiv1.NodeStatus{
+++			Capacity:    apiv1.ResourceList{},
+++			Allocatable: apiv1.ResourceList{},
+++		},
+++	}
+++	assert.False(t, NodeHasGpuMemory(nodeNoGpu))
+++}
+++
+++func TestPodRequestsGpuMemory(t *testing.T) {
+++	podNoGpu := &apiv1.Pod{
+++		Spec: apiv1.PodSpec{
+++			Containers: []apiv1.Container{
+++				apiv1.Container{
+++					Resources: apiv1.ResourceRequirements{
+++						Requests: apiv1.ResourceList{
+++							apiv1.ResourceCPU: *resource.NewQuantity(1, resource.DecimalSI),
+++						},
+++					},
+++				},
+++			},
+++		},
+++	}
+++	podWithGpu := &apiv1.Pod{Spec: apiv1.PodSpec{Containers: []apiv1.Container{
+++		apiv1.Container{
+++			Resources: apiv1.ResourceRequirements{
+++				Requests: apiv1.ResourceList{
+++					apiv1.ResourceCPU:        *resource.NewQuantity(1, resource.DecimalSI),
+++					ResourceVisenzeGPUMemory: *resource.NewQuantity(1, resource.DecimalSI),
+++				},
+++			},
+++		},
+++	}}}
+++	podWithGpu.Spec.Containers[0].Resources.Requests[ResourceVisenzeGPUMemory] = *resource.NewQuantity(1, resource.DecimalSI)
+++
+++	assert.False(t, PodRequestsGpuMemory(podNoGpu))
+++	assert.True(t, PodRequestsGpuMemory(podWithGpu))
+++}
++diff --git a/cluster-autoscaler/utils/mpscontext/mpscontext.go b/cluster-autoscaler/utils/mpscontext/mpscontext.go
++new file mode 100644
++index 000000000..f01157f47
++--- /dev/null
+++++ b/cluster-autoscaler/utils/mpscontext/mpscontext.go
++@@ -0,0 +1,6 @@
+++package mpscontext
+++
+++// Custom resource for NVIDIA MPS context
+++const (
+++	ResourceVisenzeMPSContext = "visenze.com/nvidia-mps-context"
+++)
++diff --git a/cluster-autoscaler/version/version.go b/cluster-autoscaler/version/version.go
++index b74536f7e..392964340 100644
++--- a/cluster-autoscaler/version/version.go
+++++ b/cluster-autoscaler/version/version.go
++@@ -17,4 +17,4 @@ limitations under the License.
++ package version
++ 
++ // ClusterAutoscalerVersion contains version of CA.
++-const ClusterAutoscalerVersion = "1.17.4"
+++const ClusterAutoscalerVersion = "1.17.5"
diff --git a/visenze.md b/visenze.md
new file mode 100644
index 000000000..aa065dad5
--- /dev/null
+++ b/visenze.md
@@ -0,0 +1,35 @@
+#Upgrade workflow
+Suppose that we want to upgrade from 1.17 to 1.18
+1. Pull the latest cost from the open source repository 
+1. Create a new branch `release-1.18-eks` based on the open source branch `cluster-autoscaler-release-1.18`
+1. Find the patch file `patch/1.17.patch` in the branch `release-1.17-eks`, try to use it apply to the current branch
+1. After modifications, push the code to our repository. Then it will trigger the build https://jenkins.visenze.com/job/kubernetes-cluster-autoscaler/
+1. Then we can test it in staging environment.
+
+
+#How to test the cluster autoscaler work 
+1. Test if gpu related resources can trigger the scaling up and scaling down with this pod definition.
+
+```
+apiVersion: v1
+kind: Pod
+metadata:
+  name: gpu-pod
+spec:
+  nodeSelector:
+    visenze.component: search
+    visenze.gpu: "true"
+  containers:
+    - name: digits-container
+      image: nvcr.io/nvidia/digits:20.12-tensorflow-py3
+      #image: banst/awscli
+      resources:
+        limits:
+          #visenze.com/nvidia-gpu-memory: 4988051968
+          #visenze.com/nvidia-mps-context: 9
+           nvidia.com/gpu: 1
+```
+
+#Note
+* If it can work, then generate and commit a new patch for the next version upgrade. The command to generate the patch:
+ `git diff [commit that before applying the patch] ':(exclude)cluster-autoscaler/go.mod' ':(exclude)cluster-autoscaler/go.sum' > patch/1.18.patch` 
